
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <title>测试 | Unique</title>
    <meta name="author" content="Unique" />
    <meta name="description" content="欢迎来到我的个人博客，这里记录了我关于编程、技术、生活的点点滴滴。" />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/touxiang.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>




<script src="/js/lib/preview.js"></script>









<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>UNIQUE</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;UNIQUE</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>测试</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2024/11/30
        </span>
        
        <span class="category">
            <a href="/categories/%E6%96%87%E7%AB%A0%E7%B1%BB%E5%88%AB/">
                <span class="icon">
                    <i class="fa-solid fa-bookmark fa-fw"></i>
                </span>
                文章类别
            </a>
        </span>
        
        
        <span class="tags">
            <span class="icon">
                <i class="fa-solid fa-tags fa-fw"></i>
            </span>
            
            
            <span class="tag">
                
                <a href="/tags/%E6%B5%8B%E8%AF%95/" style="color: #00a596">
                    测试
                </a>
            </span>
            
            <span class="tag">
                
                <a href="/tags/%E7%A4%BA%E4%BE%8B/" style="color: #ffa2c4">
                    示例
                </a>
            </span>
            
        </span>
        
    </div>
    
    <div class="content" v-pre>
        <h1 id="ai-实训作业"><a href="#ai-实训作业" class="headerlink" title="ai+实训作业"></a>ai+实训作业</h1><p>这是我的测试文章内容，使用 Markdown 格式书写。</p>
<span id="more"></span>



<h1 id="任务一、文件读取"><a href="#任务一、文件读取" class="headerlink" title="任务一、文件读取"></a><strong>任务一、文件读取</strong></h1><h2 id="文件（-fbx）简介"><a href="#文件（-fbx）简介" class="headerlink" title="文件（.fbx）简介"></a>文件（.fbx）简介</h2><p>FBX（Filmbox）文件是一种由Autodesk开发的专有文件格式，用于存储三维模型、动画和相关数据。</p>
<p><strong>文件类型</strong>：<strong>格式</strong>：二进制或ASCII格式。二进制格式通常用于存储复杂的三维场景和动画数据，而ASCII格式更容易阅读和编辑，适用于小型场景和测试。	<strong>主要用途</strong>：<strong>三维模型</strong>：包含几何形状（例如顶点、边和面）、材质、UV映射、骨骼和动画数据。 <strong>动画</strong>：支持骨骼动画、关键帧动画和物理模拟等。<strong>其他数据</strong>：可以包括灯光设置、相机位置、约束信息等。</p>
<p><strong>特点</strong>：<strong>广泛支持</strong>：由于Autodesk的普及和开放，FBX格式在多个三维建模和动画软件中得到广泛支持，包括Maya、3ds Max、Blender等。<strong>复杂性</strong>：由于其支持的广泛功能，FBX文件可以非常复杂，包含大量的数据和层次结构。</p>
<p><strong>使用注意事项</strong>：<strong>文件大小</strong>：由于其包含大量数据，特别是动画和高分辨率模型，文件大小可能较大。<strong>兼容性</strong>：不同版本的软件和不同的导出设置可能会影响FBX文件的兼容性和可读性。</p>
<p><strong>ASCII格式的FBX文件</strong>：可以用文本编辑器打开。这种格式是纯文本格式，人类可读，类似于XML或JSON，包含模型和动画的详细信息。例如，你可以看到顶点位置、法线、UV坐标、骨骼权重、关键帧等。</p>
<h2 id="FBX文件可以用文本编辑器打开吗？为什么？"><a href="#FBX文件可以用文本编辑器打开吗？为什么？" class="headerlink" title="FBX文件可以用文本编辑器打开吗？为什么？"></a>FBX文件可以用文本编辑器打开吗？为什么？</h2><p><strong>二进制格式的FBX文件</strong>：不能直接用文本编辑器打开，因为这种格式是二进制数据，专门为高效存储和读取而设计，不是人类可读的。如果你尝试用文本编辑器打开二进制格式的FBX文件，你会看到大量的乱码字符。</p>
<p>要判断一个FBX文件是ASCII还是二进制格式，可以检查文件的头部。ASCII格式的FBX文件通常以”FBXHeaderExtension”开始，而二进制格式的FBX文件则以特定的二进制头部开始。</p>
<p>如果你需要查看或编辑二进制格式的FBX文件，可以使用专门的工具或软件将其转换为ASCII格式。例如，Autodesk FBX Converter</p>
<h2 id="FBX文件的内容"><a href="#FBX文件的内容" class="headerlink" title="FBX文件的内容"></a>FBX<strong>文件的内容</strong></h2><p><strong>文件头</strong>：</p>
<ul>
<li>版本信息：FBX文件的版本号。</li>
<li>文件格式：ASCII或二进制格式的标识。</li>
</ul>
<p><strong>全局设置</strong>：</p>
<ul>
<li>单位设置：例如厘米、米等。</li>
<li>轴向设置：例如Y轴向上或Z轴向上。</li>
</ul>
<p><strong>模型数据</strong>：</p>
<ul>
<li><strong>顶点</strong>：三维空间中的点。</li>
<li><strong>边</strong>：连接顶点的线。</li>
<li><strong>面</strong>：由边围成的多边形（通常是三角形或四边形）。</li>
<li><strong>法线</strong>：用于光照计算的面法线和顶点法线。</li>
<li><strong>UV坐标</strong>：用于纹理映射的二维坐标。</li>
<li><strong>颜色</strong>：顶点颜色数据。</li>
</ul>
<p><strong>材质和纹理</strong>：</p>
<ul>
<li>材质属性：例如漫反射、镜面反射、透明度等。</li>
<li>纹理映射：与材质关联的纹理图像文件。</li>
</ul>
<p><strong>层次结构</strong>：</p>
<ul>
<li>物体层次：模型的父子关系，例如骨骼结构、附加物体等。</li>
</ul>
<p><strong>骨骼和蒙皮</strong>：</p>
<ul>
<li>骨骼：用于角色动画的骨骼结构。</li>
<li>权重：每个顶点受哪些骨骼影响及其权重值。</li>
</ul>
<p><strong>动画数据</strong>：</p>
<ul>
<li><strong>关键帧动画</strong>：物体在特定时间点的位置、旋转、缩放等属性。</li>
<li><strong>骨骼动画</strong>：骨骼在不同时间点的变换。</li>
<li><strong>动画曲线</strong>：描述动画属性随时间变化的曲线。</li>
</ul>
<p><strong>灯光和相机</strong>：</p>
<ul>
<li>灯光设置：灯光类型、位置、颜色、强度等。</li>
<li>相机设置：相机的位置、方向、视角等。</li>
</ul>
<p><strong>其他数据</strong>：</p>
<ul>
<li><p>约束：例如父子约束、位置约束、旋转约束等。</p>
</li>
<li><p>自定义属性：用户定义的附加信息。</p>
<p>示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">; FBX <span class="number">7.4</span><span class="number">.0</span> project file</span><br><span class="line">FBXHeaderExtension:  &#123;</span><br><span class="line">    FBXHeaderVersion: <span class="number">1003</span></span><br><span class="line">    FBXVersion: <span class="number">7400</span></span><br><span class="line">    CreationTimeStamp: &#123;</span><br><span class="line">        Version: <span class="number">1000</span></span><br><span class="line">        Year: <span class="number">2024</span></span><br><span class="line">        Month: <span class="number">7</span></span><br><span class="line">        Day: <span class="number">4</span></span><br><span class="line">        Hour: <span class="number">12</span></span><br><span class="line">        Minute: <span class="number">0</span></span><br><span class="line">        Second: <span class="number">0</span></span><br><span class="line">        Millisecond: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Creator: <span class="string">&quot;FBX SDK/FBX Plugins version 2019.5&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">GlobalSettings:  &#123;</span><br><span class="line">    Version: <span class="number">1000</span></span><br><span class="line">    Properties70:  &#123;</span><br><span class="line">        P: <span class="string">&quot;UpAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;UpAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;FrontAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">2</span></span><br><span class="line">        P: <span class="string">&quot;FrontAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;CoordAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">0</span></span><br><span class="line">        P: <span class="string">&quot;CoordAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;UnitScaleFactor&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Objects:  &#123;</span><br><span class="line">    Model: <span class="string">&quot;Model::Cube&quot;</span>, <span class="string">&quot;Mesh&quot;</span> &#123;</span><br><span class="line">        Version: <span class="number">232</span></span><br><span class="line">        Properties70:  &#123;</span><br><span class="line">            P: <span class="string">&quot;InheritType&quot;</span>, <span class="string">&quot;enum&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Vertices: *<span class="number">24</span> &#123;</span><br><span class="line">            a: <span class="number">-50</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">0</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">-50</span></span><br><span class="line">        &#125;</span><br><span class="line">        PolygonVertexIndex: *<span class="number">36</span> &#123;</span><br><span class="line">            a: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        GeometryVersion: <span class="number">124</span></span><br><span class="line">    &#125;</span><br><span class="line">    Material: <span class="string">&quot;Material::Lambert&quot;</span> &#123;</span><br><span class="line">        Version: <span class="number">102</span></span><br><span class="line">        ShadingModel: <span class="string">&quot;Lambert&quot;</span></span><br><span class="line">        Properties70:  &#123;</span><br><span class="line">            P: <span class="string">&quot;DiffuseColor&quot;</span>, <span class="string">&quot;ColorRGB&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>,<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">0.8</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Connections:  &#123;</span><br><span class="line">    C: <span class="string">&quot;OO&quot;</span>, <span class="string">&quot;Model::Cube&quot;</span>, <span class="string">&quot;Model::RootNode&quot;</span></span><br><span class="line">    C: <span class="string">&quot;OO&quot;</span>, <span class="string">&quot;Material::Lambert&quot;</span>, <span class="string">&quot;Model::Cube&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="支持FBX格式的软件"><a href="#支持FBX格式的软件" class="headerlink" title="支持FBX格式的软件"></a>支持FBX格式的软件</h2><p>Autodesk Maya;Autodesk 3ds Max;Blender;Cinema 4D;ZBrush;Unity;Unreal Engine;Autodesk Revit;Autodesk AutoCAD;Houdini;Modo;SketchUp;Autodesk FBX Converter;Noesis;</p>
<h2 id="FBX文件的结构"><a href="#FBX文件的结构" class="headerlink" title="FBX文件的结构"></a>FBX文件的结构</h2><p>FBX文件的结构是层次化的，可以包含丰富的三维数据和动画信息。FBX文件分为ASCII和二进制两种格式，但其内部数据结构基本一致</p>
<ol>
<li><p>文件头 (Header)</p>
<p>文件头包含了基本信息，如文件版本、创建时间等。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">FBXHeaderExtension: &#123;</span><br><span class="line">    FBXHeaderVersion: <span class="number">1003</span></span><br><span class="line">    FBXVersion: <span class="number">7500</span></span><br><span class="line">    CreationTimeStamp: &#123;</span><br><span class="line">        Version: <span class="number">1000</span></span><br><span class="line">        Year: <span class="number">2024</span></span><br><span class="line">        Month: <span class="number">7</span></span><br><span class="line">        Day: <span class="number">4</span></span><br><span class="line">        Hour: <span class="number">12</span></span><br><span class="line">        Minute: <span class="number">0</span></span><br><span class="line">        Second: <span class="number">0</span></span><br><span class="line">        Millisecond: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    Creator: <span class="string">&quot;FBX SDK/FBX Plugins version 2020.0&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>全局设置 (Global Settings)</p>
<p>全局设置包括单位设置、坐标轴方向等信息。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">GlobalSettings: &#123;</span><br><span class="line">    Version: <span class="number">1000</span></span><br><span class="line">    Properties70: &#123;</span><br><span class="line">        P: <span class="string">&quot;UpAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;UpAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;FrontAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">2</span></span><br><span class="line">        P: <span class="string">&quot;FrontAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;CoordAxis&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">0</span></span><br><span class="line">        P: <span class="string">&quot;CoordAxisSign&quot;</span>, <span class="string">&quot;int&quot;</span>, <span class="string">&quot;Integer&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;UnitScaleFactor&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1.0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>对象定义 (Objects)</li>
</ol>
<p>对象定义部分包含所有的三维模型、材质、灯光、相机等对象的具体数据。</p>
<p>   3.1 模型 (Model)</p>
<p>模型对象包含顶点、面、法线、UV坐标等几何数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Objects: &#123;</span><br><span class="line">    Model: <span class="string">&quot;Model::Cube&quot;</span>, <span class="string">&quot;Mesh&quot;</span> &#123;</span><br><span class="line">        Version: <span class="number">232</span></span><br><span class="line">        Properties70: &#123;</span><br><span class="line">            P: <span class="string">&quot;InheritType&quot;</span>, <span class="string">&quot;enum&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        Vertices: *<span class="number">24</span> &#123;</span><br><span class="line">            a: <span class="number">-50</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">0</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">0</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">50</span>,<span class="number">50</span>,<span class="number">100</span>,<span class="number">-50</span>,<span class="number">-50</span>,<span class="number">100</span>,<span class="number">-50</span></span><br><span class="line">        &#125;</span><br><span class="line">        PolygonVertexIndex: *<span class="number">36</span> &#123;</span><br><span class="line">            a: <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">-1</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">-1</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">-1</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-1</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">-1</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        GeometryVersion: <span class="number">124</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.2 材质 (Material)</p>
<p>材质对象定义了材质属性，如漫反射颜色、镜面反射等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Material: <span class="string">&quot;Material::Lambert&quot;</span> &#123;</span><br><span class="line">    Version: <span class="number">102</span></span><br><span class="line">    ShadingModel: <span class="string">&quot;Lambert&quot;</span></span><br><span class="line">    Properties70: &#123;</span><br><span class="line">        P: <span class="string">&quot;DiffuseColor&quot;</span>, <span class="string">&quot;ColorRGB&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>,<span class="number">0.8</span>,<span class="number">0.8</span>,<span class="number">0.8</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.3 动画 (Animation)</p>
<p>动画对象定义了关键帧、骨骼动画等信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">AnimationCurve: &#123;</span><br><span class="line">    KeyTime: *<span class="number">6</span> &#123;</span><br><span class="line">        a: <span class="number">0</span>,<span class="number">1924423255555</span>,<span class="number">3848846511111</span>,<span class="number">5773269766666</span>,<span class="number">7697693022222</span>,<span class="number">9622116277777</span></span><br><span class="line">    &#125;</span><br><span class="line">    KeyValueFloat: *<span class="number">6</span> &#123;</span><br><span class="line">        a: <span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1</span>,<span class="number">0.5</span>,<span class="number">0</span>,<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>连接 (Connections)</li>
</ol>
<p>连接部分定义了对象之间的关系和层次结构，例如父子关系、材质与模型的关联等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Connections: &#123;</span><br><span class="line">    C: <span class="string">&quot;OO&quot;</span>, <span class="string">&quot;Model::Cube&quot;</span>, <span class="string">&quot;Model::RootNode&quot;</span></span><br><span class="line">    C: <span class="string">&quot;OO&quot;</span>, <span class="string">&quot;Material::Lambert&quot;</span>, <span class="string">&quot;Model::Cube&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>附加信息 (Additional Information)</li>
</ol>
<p>根据需要，FBX文件还可以包含灯光、相机、约束、物理属性等附加信息。</p>
<p>5.1 灯光 (Light)</p>
<p>灯光对象定义了灯光的类型、位置、颜色等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Light: <span class="string">&quot;Light::PointLight&quot;</span> &#123;</span><br><span class="line">    Version: <span class="number">103</span></span><br><span class="line">    Properties70: &#123;</span><br><span class="line">        P: <span class="string">&quot;Color&quot;</span>, <span class="string">&quot;ColorRGB&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;A&quot;</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;Intensity&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5.2 相机 (Camera)</p>
<p>相机对象定义了相机的位置、视角、焦距等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Camera: <span class="string">&quot;Camera::Camera1&quot;</span> &#123;</span><br><span class="line">    Version: <span class="number">103</span></span><br><span class="line">    Properties70: &#123;</span><br><span class="line">        P: <span class="string">&quot;FieldOfView&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">45</span></span><br><span class="line">        P: <span class="string">&quot;NearPlane&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1</span></span><br><span class="line">        P: <span class="string">&quot;FarPlane&quot;</span>, <span class="string">&quot;double&quot;</span>, <span class="string">&quot;Number&quot;</span>, <span class="string">&quot;&quot;</span>,<span class="number">1000</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="怎样用代码获取FBX文件的数据？"><a href="#怎样用代码获取FBX文件的数据？" class="headerlink" title="怎样用代码获取FBX文件的数据？"></a>怎样用代码获取FBX文件的数据？</h2><p>在Visual Studio中使用FBX SDK获取FBX文件的数据需要几个步骤：安装FBX SDK、配置Visual Studio项目、编写代码以读取FBX文件的数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fbxsdk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化FBX SDK</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeSdkObjects</span><span class="params">(FbxManager*&amp; pManager, FbxScene*&amp; pScene)</span> </span>&#123;</span><br><span class="line">    pManager = FbxManager::<span class="built_in">Create</span>();</span><br><span class="line">    FbxIOSettings* ios = FbxIOSettings::<span class="built_in">Create</span>(pManager, IOSROOT);</span><br><span class="line">    pManager-&gt;<span class="built_in">SetIOSettings</span>(ios);</span><br><span class="line">    pScene = FbxScene::<span class="built_in">Create</span>(pManager, <span class="string">&quot;My Scene&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载FBX文件</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoadScene</span><span class="params">(FbxManager* pManager, FbxDocument* pScene, <span class="type">const</span> <span class="type">char</span>* pFilename)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> lFileMajor, lFileMinor, lFileRevision;</span><br><span class="line">    <span class="type">int</span> lSDKMajor, lSDKMinor, lSDKRevision;</span><br><span class="line">    <span class="type">bool</span> lStatus;</span><br><span class="line"></span><br><span class="line">    FbxManager::<span class="built_in">GetFileFormatVersion</span>(lSDKMajor, lSDKMinor, lSDKRevision);</span><br><span class="line"></span><br><span class="line">    FbxImporter* lImporter = FbxImporter::<span class="built_in">Create</span>(pManager, <span class="string">&quot;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!lImporter-&gt;<span class="built_in">Initialize</span>(pFilename, <span class="number">-1</span>, pManager-&gt;<span class="built_in">GetIOSettings</span>())) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Call to FbxImporter::Initialize() failed.&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error returned: &quot;</span> &lt;&lt; lImporter-&gt;<span class="built_in">GetStatus</span>().<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    lImporter-&gt;<span class="built_in">GetFileVersion</span>(lFileMajor, lFileMinor, lFileRevision);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;FBX file version: &quot;</span> &lt;&lt; lFileMajor &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; lFileMinor &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; lFileRevision &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    lStatus = lImporter-&gt;<span class="built_in">Import</span>(pScene);</span><br><span class="line"></span><br><span class="line">    lImporter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lStatus;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历FBX节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessNode</span><span class="params">(FbxNode* pNode)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Node Name: &quot;</span> &lt;&lt; pNode-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNode-&gt;<span class="built_in">GetNodeAttributeCount</span>(); i++) &#123;</span><br><span class="line">        FbxNodeAttribute* pAttribute = pNode-&gt;<span class="built_in">GetNodeAttributeByIndex</span>(i);</span><br><span class="line">        <span class="keyword">if</span> (pAttribute) &#123;</span><br><span class="line">            std::string attributeType;</span><br><span class="line">            <span class="keyword">switch</span> (pAttribute-&gt;<span class="built_in">GetAttributeType</span>()) &#123;</span><br><span class="line">                <span class="keyword">case</span> FbxNodeAttribute::eMarker: attributeType = <span class="string">&quot;Marker&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FbxNodeAttribute::eSkeleton: attributeType = <span class="string">&quot;Skeleton&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FbxNodeAttribute::eMesh: attributeType = <span class="string">&quot;Mesh&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FbxNodeAttribute::eCamera: attributeType = <span class="string">&quot;Camera&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> FbxNodeAttribute::eLight: attributeType = <span class="string">&quot;Light&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>: attributeType = <span class="string">&quot;Unknown&quot;</span>; <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;  Attribute Type: &quot;</span> &lt;&lt; attributeType &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNode-&gt;<span class="built_in">GetChildCount</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">ProcessNode</span>(pNode-&gt;<span class="built_in">GetChild</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;FBX file path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* lFilename = argv[<span class="number">1</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化FBX SDK管理器和场景</span></span><br><span class="line">    FbxManager* lSdkManager = <span class="literal">nullptr</span>;</span><br><span class="line">    FbxScene* lScene = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">InitializeSdkObjects</span>(lSdkManager, lScene);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载FBX文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LoadScene</span>(lSdkManager, lScene, lFilename)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;An error occurred while loading the scene...&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理FBX文件的根节点</span></span><br><span class="line">    <span class="built_in">ProcessNode</span>(lScene-&gt;<span class="built_in">GetRootNode</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁FBX SDK管理器</span></span><br><span class="line">    lSdkManager-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明</p>
<ol>
<li><strong>InitializeSdkObjects</strong>：初始化FBX SDK管理器和场景对象。</li>
<li><strong>LoadScene</strong>：加载FBX文件并将其导入到场景对象中。</li>
<li><strong>ProcessNode</strong>：递归处理FBX节点，打印节点名称和属性类型。</li>
<li><strong>main</strong>：主函数中，调用初始化和加载函数，然后处理FBX文件的根节点。</li>
</ol>
<h2 id="FBX文件的节点（Node）结构，节点信息的读取代码。"><a href="#FBX文件的节点（Node）结构，节点信息的读取代码。" class="headerlink" title="FBX文件的节点（Node）结构，节点信息的读取代码。"></a>FBX文件的节点（Node）结构，节点信息的读取代码。</h2><p>在FBX SDK中，节点（Node）是FBX场景中的基本元素，可以表示模型、灯光、相机等对象。每个节点可以包含一个节点属性（Node Attribute），如模型属性（Mesh）、灯光属性（Light）、相机属性（Camera）等</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fbxsdk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化FBX SDK</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeSdkObjects</span><span class="params">(FbxManager*&amp; pManager, FbxScene*&amp; pScene)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建FBX管理器</span></span><br><span class="line">    pManager = FbxManager::<span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">if</span> (!pManager) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Manager!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO设置</span></span><br><span class="line">    FbxIOSettings* ios = FbxIOSettings::<span class="built_in">Create</span>(pManager, IOSROOT);</span><br><span class="line">    pManager-&gt;<span class="built_in">SetIOSettings</span>(ios);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建场景</span></span><br><span class="line">    pScene = FbxScene::<span class="built_in">Create</span>(pManager, <span class="string">&quot;My Scene&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pScene) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Scene!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载FBX文件到场景</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoadScene</span><span class="params">(FbxManager* pManager, FbxScene* pScene, <span class="type">const</span> <span class="type">char</span>* pFilename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建导入器</span></span><br><span class="line">    FbxImporter* pImporter = FbxImporter::<span class="built_in">Create</span>(pManager, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImporter) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Importer!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化导入器</span></span><br><span class="line">    <span class="keyword">if</span> (!pImporter-&gt;<span class="built_in">Initialize</span>(pFilename, <span class="number">-1</span>, pManager-&gt;<span class="built_in">GetIOSettings</span>())) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to initialize FBX Importer with file &quot;</span> &lt;&lt; pFilename &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error returned: &quot;</span> &lt;&lt; pImporter-&gt;<span class="built_in">GetStatus</span>().<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入文件到场景</span></span><br><span class="line">    <span class="keyword">if</span> (!pImporter-&gt;<span class="built_in">Import</span>(pScene)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to import FBX file &quot;</span> &lt;&lt; pFilename &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error returned: &quot;</span> &lt;&lt; pImporter-&gt;<span class="built_in">GetStatus</span>().<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁导入器</span></span><br><span class="line">    pImporter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessNode</span><span class="params">(FbxNode* pNode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印节点名称</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Node Name: &quot;</span> &lt;&lt; pNode-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点属性</span></span><br><span class="line">    FbxNodeAttribute* pNodeAttribute = pNode-&gt;<span class="built_in">GetNodeAttribute</span>();</span><br><span class="line">    <span class="keyword">if</span> (pNodeAttribute) &#123;</span><br><span class="line">        <span class="comment">// 打印节点属性类型</span></span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;  Node Attribute Type: &quot;</span> &lt;&lt; pNodeAttribute-&gt;<span class="built_in">GetAttributeTypeName</span>() &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 根据属性类型进一步处理</span></span><br><span class="line">        <span class="keyword">switch</span> (pNodeAttribute-&gt;<span class="built_in">GetAttributeType</span>()) &#123;</span><br><span class="line">            <span class="keyword">case</span> FbxNodeAttribute::eMesh:</span><br><span class="line">                <span class="comment">// 处理Mesh属性</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;    Mesh Node&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FbxNodeAttribute::eSkeleton:</span><br><span class="line">                <span class="comment">// 处理Skeleton属性</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;    Skeleton Node&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FbxNodeAttribute::eCamera:</span><br><span class="line">                <span class="comment">// 处理Camera属性</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;    Camera Node&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FbxNodeAttribute::eLight:</span><br><span class="line">                <span class="comment">// 处理Light属性</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;    Light Node&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="comment">// 其他属性类型</span></span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;    Other Node Attribute&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNode-&gt;<span class="built_in">GetChildCount</span>(); i++) &#123;</span><br><span class="line">        <span class="built_in">ProcessNode</span>(pNode-&gt;<span class="built_in">GetChild</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;FBX file path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化FBX SDK</span></span><br><span class="line">    FbxManager* pManager = <span class="literal">nullptr</span>;</span><br><span class="line">    FbxScene* pScene = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">InitializeSdkObjects</span>(pManager, pScene);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载FBX文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LoadScene</span>(pManager, pScene, filename)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to load FBX file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取根节点并处理</span></span><br><span class="line">    FbxNode* pRootNode = pScene-&gt;<span class="built_in">GetRootNode</span>();</span><br><span class="line">    <span class="keyword">if</span> (pRootNode) &#123;</span><br><span class="line">        <span class="built_in">ProcessNode</span>(pRootNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: FBX file contains no root node!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁FBX SDK对象</span></span><br><span class="line">    pManager-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码说明</p>
<ul>
<li><strong>InitializeSdkObjects</strong>：初始化FBX SDK管理器和场景对象。</li>
<li><strong>LoadScene</strong>：加载指定的FBX文件到场景中。</li>
<li><strong>ProcessNode</strong>：递归遍历FBX场景中的节点，并打印节点名称和节点属性类型。</li>
<li><strong>main</strong>：主函数中，首先初始化FBX SDK，然后加载指定的FBX文件，获取并处理根节点的信息。</li>
</ul>
<h2 id="FBX-SDK包含哪些API函数？"><a href="#FBX-SDK包含哪些API函数？" class="headerlink" title="FBX SDK包含哪些API函数？"></a>FBX SDK包含哪些API函数？</h2><p>主要类和函数</p>
<ul>
<li><p><strong>FbxManager</strong>:</p>
<p><code>FbxManager::Create()</code>: 创建FBX管理器。</p>
<p><code>FbxManager::Destroy()</code>: 销毁FBX管理器及其相关资源。</p>
</li>
<li><p><strong>FbxScene</strong>:</p>
<p><code>FbxScene::Create(FbxManager* pManager, const char* pName)</code>: 创建FBX场景。</p>
<p><code>FbxScene::Destroy(bool pRecursive)</code>: 销毁FBX场景及其相关资源。</p>
<p><code>FbxScene::GetRootNode()</code>: 获取FBX场景的根节点。</p>
</li>
<li><p><strong>FbxImporter</strong> 和 <strong>FbxExporter</strong>:</p>
<p><code>FbxImporter::Create(FbxManager* pManager, const char* pName)</code>: 创建FBX导入器。</p>
<p><code>FbxImporter::Initialize(const char* pFileName, int pFileFormat, FbxIOSettings* pIOSettings)</code>: 初始化FBX导入器并打开指定的文件。</p>
<p><code>FbxImporter::Import(FbxScene* pScene)</code>: 导入FBX文件到场景中。</p>
<p><code>FbxImporter::Destroy()</code>: 销毁FBX导入器及其相关资源。</p>
<p><code>FbxExporter::Create(FbxManager* pManager, const char* pName)</code>: 创建FBX导出器。</p>
<p><code>FbxExporter::Initialize(const char* pFileName, int pFileFormat, FbxIOSettings* pIOSettings)</code>: 初始化FBX导出器并指定输出文件。</p>
<p><code>FbxExporter::Export(FbxScene* pScene)</code>: 将FBX场景导出为文件。</p>
<p><code>FbxExporter::Destroy()</code>: 销毁FBX导出器及其相关资源。</p>
</li>
<li><p><strong>FbxNode</strong>:</p>
<p><code>FbxNode::GetName()</code>: 获取节点名称。</p>
<p><code>FbxNode::GetNodeAttribute()</code>: 获取节点属性。</p>
<p><code>FbxNode::GetChildCount()</code>: 获取子节点数量。</p>
<p><code>FbxNode::GetChild(int pIndex)</code>: 获取指定索引处的子节点</p>
<p><code>FbxNode::AddChild(FbxNode* pNode)</code>: 添加子节点。</p>
<p><code>FbxNode::RemoveChild(FbxNode* pNode)</code>: 移除子节点。</p>
</li>
<li><p><strong>FbxNodeAttribute</strong>:</p>
<p><code>FbxNode::GetNodeAttribute()</code>: 获取节点属性。</p>
<p><code>FbxNodeAttribute::GetAttributeType()</code>: 获取节点属性的类型。</p>
<p>类型包括 <code>eUnknown</code>, <code>eNull</code>, <code>eMarker</code>, <code>eSkeleton</code>, <code>eMesh</code>, <code>eNurbs</code>, <code>ePatch</code>, <code>eCamera</code>, <code>eCameraStereo</code>, <code>eCameraSwitcher</code>, <code>eLight</code>, <code>eOpticalReference</code>, <code>eOpticalMarker</code>, <code>eNurbsCurve</code>, <code>eTrimNurbsSurface</code>, <code>eBoundary</code>, <code>eNurbsSurface</code>, <code>eShape</code>, <code>eLODGroup</code>, <code>eSubDiv</code>, <code>eCachedEffect</code>, <code>eLine</code>, <code>eFbxLast</code>.</p>
</li>
<li><p><strong>FbxNodeAttribute</strong> 派生类：</p>
<p><code>FbxMesh</code>: 处理三角形网格数据。</p>
<ul>
<li><code>FbxCamera</code>: 处理摄像机属性。</li>
</ul>
<p><code>FbxLight</code>: 处理光源属性。</p>
<p><code>FbxSkeleton</code>: 处理骨骼属性等。</p>
</li>
<li><p><strong>FbxProperty</strong> 和 <strong>FbxProperty</strong>:</p>
<p><code>FbxObject::RootPropertyBegin()</code>: 获取根属性开始。</p>
<p><code>FbxObject::RootPropertyEnd()</code>: 获取根属性结束。</p>
<h3 id="用C-实现读取FBX文件的数据：顶点、多边形索引、包围盒等。"><a href="#用C-实现读取FBX文件的数据：顶点、多边形索引、包围盒等。" class="headerlink" title="用C++实现读取FBX文件的数据：顶点、多边形索引、包围盒等。"></a>用C++实现读取FBX文件的数据：顶点、多边形索引、包围盒等。</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fbxsdk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化FBX SDK</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InitializeSdkObjects</span><span class="params">(FbxManager*&amp; pManager, FbxScene*&amp; pScene)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建FBX管理器</span></span><br><span class="line">    pManager = FbxManager::<span class="built_in">Create</span>();</span><br><span class="line">    <span class="keyword">if</span> (!pManager) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Manager!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建IO设置</span></span><br><span class="line">    FbxIOSettings* ios = FbxIOSettings::<span class="built_in">Create</span>(pManager, IOSROOT);</span><br><span class="line">    pManager-&gt;<span class="built_in">SetIOSettings</span>(ios);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建场景</span></span><br><span class="line">    pScene = FbxScene::<span class="built_in">Create</span>(pManager, <span class="string">&quot;My Scene&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pScene) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Scene!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载FBX文件到场景</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LoadScene</span><span class="params">(FbxManager* pManager, FbxScene* pScene, <span class="type">const</span> <span class="type">char</span>* pFilename)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建导入器</span></span><br><span class="line">    FbxImporter* pImporter = FbxImporter::<span class="built_in">Create</span>(pManager, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!pImporter) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Unable to create FBX Importer!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化导入器</span></span><br><span class="line">    <span class="keyword">if</span> (!pImporter-&gt;<span class="built_in">Initialize</span>(pFilename, <span class="number">-1</span>, pManager-&gt;<span class="built_in">GetIOSettings</span>())) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to initialize FBX Importer with file &quot;</span> &lt;&lt; pFilename &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error returned: &quot;</span> &lt;&lt; pImporter-&gt;<span class="built_in">GetStatus</span>().<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 导入文件到场景</span></span><br><span class="line">    <span class="keyword">if</span> (!pImporter-&gt;<span class="built_in">Import</span>(pScene)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to import FBX file &quot;</span> &lt;&lt; pFilename &lt;&lt; std::endl;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error returned: &quot;</span> &lt;&lt; pImporter-&gt;<span class="built_in">GetStatus</span>().<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁导入器</span></span><br><span class="line">    pImporter-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取FBX模型的顶点和多边形索引</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ReadMeshData</span><span class="params">(FbxMesh* pMesh)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取顶点信息</span></span><br><span class="line">    FbxVector4* pVertices = pMesh-&gt;<span class="built_in">GetControlPoints</span>();</span><br><span class="line">    <span class="type">int</span> vertexCount = pMesh-&gt;<span class="built_in">GetControlPointsCount</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Vertex Count: &quot;</span> &lt;&lt; vertexCount &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; vertexCount; ++i) &#123;</span><br><span class="line">        FbxVector4 vertex = pVertices[i];</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Vertex &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: (&quot;</span> &lt;&lt; vertex[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; vertex[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取多边形索引</span></span><br><span class="line">    <span class="type">int</span> polygonCount = pMesh-&gt;<span class="built_in">GetPolygonCount</span>();</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Polygon Count: &quot;</span> &lt;&lt; polygonCount &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; polygonCount; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> vertexCount = pMesh-&gt;<span class="built_in">GetPolygonSize</span>(i);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Polygon &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; vertexCount; ++j) &#123;</span><br><span class="line">            <span class="type">int</span> vertexIndex = pMesh-&gt;<span class="built_in">GetPolygonVertex</span>(i, j);</span><br><span class="line">            std::cout &lt;&lt; vertexIndex &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取包围盒（Bounding Box）</span></span><br><span class="line">    FbxVector4 min, max;</span><br><span class="line">    pMesh-&gt;<span class="built_in">GetBoundingBoxMin</span>(min);</span><br><span class="line">    pMesh-&gt;<span class="built_in">GetBoundingBoxMax</span>(max);</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bounding Box Min: (&quot;</span> &lt;&lt; min[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; min[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; min[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Bounding Box Max: (&quot;</span> &lt;&lt; max[<span class="number">0</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; max[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; max[<span class="number">2</span>] &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归遍历节点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ProcessNode</span><span class="params">(FbxNode* pNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pNode)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取节点属性</span></span><br><span class="line">    FbxNodeAttribute* pNodeAttribute = pNode-&gt;<span class="built_in">GetNodeAttribute</span>();</span><br><span class="line">    <span class="keyword">if</span> (pNodeAttribute) &#123;</span><br><span class="line">        <span class="comment">// 处理Mesh属性</span></span><br><span class="line">        <span class="keyword">if</span> (pNodeAttribute-&gt;<span class="built_in">GetAttributeType</span>() == FbxNodeAttribute::eMesh) &#123;</span><br><span class="line">            FbxMesh* pMesh = pNode-&gt;<span class="built_in">GetMesh</span>();</span><br><span class="line">            <span class="keyword">if</span> (pMesh) &#123;</span><br><span class="line">                std::cout &lt;&lt; <span class="string">&quot;Processing Mesh Node: &quot;</span> &lt;&lt; pNode-&gt;<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">                <span class="built_in">ReadMeshData</span>(pMesh);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归处理子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; pNode-&gt;<span class="built_in">GetChildCount</span>(); ++i) &#123;</span><br><span class="line">        <span class="built_in">ProcessNode</span>(pNode-&gt;<span class="built_in">GetChild</span>(i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;FBX file path&gt;&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* filename = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化FBX SDK</span></span><br><span class="line">    FbxManager* pManager = <span class="literal">nullptr</span>;</span><br><span class="line">    FbxScene* pScene = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">InitializeSdkObjects</span>(pManager, pScene);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载FBX文件</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">LoadScene</span>(pManager, pScene, filename)) &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: Failed to load FBX file &quot;</span> &lt;&lt; filename &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取根节点并处理</span></span><br><span class="line">    FbxNode* pRootNode = pScene-&gt;<span class="built_in">GetRootNode</span>();</span><br><span class="line">    <span class="keyword">if</span> (pRootNode) &#123;</span><br><span class="line">        <span class="built_in">ProcessNode</span>(pRootNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="string">&quot;Error: FBX file contains no root node!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 销毁FBX SDK对象</span></span><br><span class="line">    pManager-&gt;<span class="built_in">Destroy</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="任务二、文件读取"><a href="#任务二、文件读取" class="headerlink" title="任务二、文件读取"></a><strong>任务二、文件读取</strong></h1><h2 id="什么是Assimp开源库？"><a href="#什么是Assimp开源库？" class="headerlink" title="什么是Assimp开源库？"></a>什么是Assimp开源库？</h2><p>Assimp（Open Asset Import Library）是一个开源的库，用于处理各种3D模型文件的导入功能。它能够读取多种不同格式的3D模型文件，如OBJ、FBX、STL、DAE等，提供了统一的接口和数据结构来访问这些模型的数据。Assimp的主要功能包括：</p>
<ol>
<li><strong>模型导入</strong>：支持从多种格式的3D模型文件中导入数据，包括顶点信息、材质数据、UV坐标、法线、动画等。</li>
<li><strong>数据预处理</strong>：提供了处理模型数据的功能，如计算边界框、顶点法线生成、切线空间生成等。</li>
<li><strong>数据格式转换</strong>：可以将导入的模型数据转换为统一的数据结构，方便应用程序进行处理和渲染。</li>
<li><strong>格式检查</strong>：能够验证和修复一些格式不完整或损坏的3D模型文件。</li>
<li><strong>跨平台支持</strong>：Assimp支持多个主流操作系统（Windows、Linux、macOS等），并且可以与多个编程语言（如C++、C、Python等）集成使用。</li>
<li><strong>免费和开源</strong>：Assimp是免费的开源软件，遵循BSD许可证，可以用于商业和非商业项目。</li>
</ol>
<h2 id="Assimp开源库有哪些功能？"><a href="#Assimp开源库有哪些功能？" class="headerlink" title="Assimp开源库有哪些功能？"></a>Assimp开源库有哪些功能？</h2><p><strong>支持的文件格式</strong>：</p>
<ul>
<li>Assimp支持导入超过40种不同的3D文件格式，包括但不限于：OBJ、FBX、STL、DAE、3DS、Blend、Collada、PLY等。这使得开发者可以轻松地处理来自不同软件和工具的3D模型数据。</li>
</ul>
<p><strong>统一的数据访问接口</strong>：</p>
<ul>
<li>Assimp提供了统一的数据访问接口和数据结构，使开发者可以以统一的方式访问不同格式的3D模型数据，包括顶点信息、法线、UV坐标、材质信息、动画数据等。</li>
</ul>
<p><strong>数据预处理和修复</strong>：</p>
<ul>
<li>Assimp可以对导入的3D模型数据进行预处理和修复，包括计算边界框、生成顶点法线和切线空间、优化数据结构等，以便应用程序更高效地处理和渲染模型。</li>
</ul>
<p><strong>模型数据转换</strong>：</p>
<ul>
<li>Assimp支持将导入的3D模型数据转换为应用程序所需的统一格式，这有助于开发者在不同的应用场景中使用相同的数据结构，简化了模型数据的管理和处理。</li>
</ul>
<p><strong>错误检查和修复</strong>：</p>
<ul>
<li>Assimp能够检测和修复一些3D模型文件中可能存在的格式错误或损坏，帮助开发者在导入模型时处理潜在的问题。</li>
</ul>
<p><strong>跨平台支持</strong>：</p>
<ul>
<li>Assimp支持多个主流操作系统，包括Windows、Linux、macOS等，同时提供了多种编程语言的接口（如C++、C、Python等），可以方便地集成到不同的开发环境中使用。</li>
</ul>
<p><strong>开源和免费</strong>：</p>
<ul>
<li>Assimp是开源的软件，采用BSD许可证，可以自由使用和修改，适用于商业和非商业项目。</li>
</ul>
<p><strong>动画和骨骼支持</strong>：</p>
<ul>
<li>Assimp能够处理包括动画和骨骼在内的复杂模型数据，使得开发者可以在应用程序中实现动态的模型渲染和动画效果。</li>
</ul>
<h2 id="Assimp是用什么语言实现的？"><a href="#Assimp是用什么语言实现的？" class="headerlink" title="Assimp是用什么语言实现的？"></a>Assimp是用什么语言实现的？</h2><p>Assimp（Open Asset Import Library）主要是用C++实现的。C++是一种高效的系统编程语言，非常适合开发需要处理大量数据和性能要求较高的软件库和应用程序。Assimp利用C++的特性来实现对多种3D模型文件格式的导入功能，并提供了灵活的接口和数据结构，方便开发者在不同的平台和环境中使用和集成。</p>
<h2 id="Assimp的类结构？"><a href="#Assimp的类结构？" class="headerlink" title="Assimp的类结构？"></a>Assimp的类结构？</h2><p><strong>Assimp::Importer</strong>:</p>
<ul>
<li>主要类，用于导入3D模型文件并转换为Assimp的数据结构。</li>
<li>包含方法如<code>ReadFile</code>用于从文件读取数据，<code>GetScene</code>获取导入的场景数据等。</li>
</ul>
<p><strong>Assimp::Scene</strong>:</p>
<ul>
<li>表示一个完整的导入场景，包含所有的模型数据和其他相关信息。</li>
<li>可以访问场景中的所有节点，材质、纹理、动画等。</li>
</ul>
<p><strong>Assimp::Node</strong>:</p>
<ul>
<li>表示场景中的一个节点，通常对应于3D模型中的一个对象，如一个网格、灯光、相机等。</li>
<li>每个节点包含一个或多个Mesh对象。</li>
</ul>
<p><strong>Assimp::Mesh</strong>:</p>
<ul>
<li>表示一个网格对象，包含了顶点数据、面数据、UV坐标、法线等。</li>
<li>包含方法如<code>GetVertexCount</code>获取顶点数量，<code>GetFaces</code>获取面数据等。</li>
</ul>
<p><strong>Assimp::Material</strong>:</p>
<ul>
<li>表示模型的材质信息，包括颜色、纹理、反射率等。</li>
<li>可以获取和设置材质属性，如<code>GetTextureCount</code>获取纹理数量，<code>GetColor</code>获取颜色信息等。</li>
</ul>
<p><strong>Assimp::Texture</strong>:</p>
<ul>
<li>表示一个纹理对象，可以是Diffuse贴图、法线贴图等。</li>
<li>包含方法如<code>GetWidth</code>和<code>GetHeight</code>获取纹理的宽度和高度等。</li>
</ul>
<p><strong>Assimp::Animation</strong>:</p>
<ul>
<li>表示模型的动画数据，包括关键帧信息、骨骼动画等。</li>
<li>可以获取动画的时间轴，关键帧的位移和旋转等。</li>
</ul>
<p><strong>Assimp::Bone</strong>:</p>
<ul>
<li>表示模型的骨骼信息，用于骨骼动画。</li>
<li>可以获取骨骼名称、骨骼的权重和偏移矩阵等。</li>
</ul>
<h2 id="如何获取Assimp开源库？"><a href="#如何获取Assimp开源库？" class="headerlink" title="如何获取Assimp开源库？"></a>如何获取Assimp开源库？</h2><p>下载Assimp</p>
<ol>
<li><strong>官方网站</strong>：访问Assimp的官方网站 <a target="_blank" rel="noopener" href="http://www.assimp.org/">http://www.assimp.org/</a>。</li>
<li><strong>GitHub</strong>：Assimp也托管在GitHub上，你可以在其GitHub仓库获取最新的源代码和文档：<a target="_blank" rel="noopener" href="https://github.com/assimp/assimp">https://github.com/assimp/assimp</a>。</li>
</ol>
<p>编译和安装Assimp</p>
<p>Assimp提供了跨平台的编译和安装方式。以下是一般的步骤：</p>
<ol>
<li><p><strong>下载源代码</strong>：</p>
<ul>
<li>从GitHub仓库下载源代码，或者从官网下载源代码压缩包并解压。</li>
</ul>
</li>
<li><p><strong>构建Assimp</strong>：</p>
<ul>
<li><p>Assimp提供了CMake构建系统支持，你可以使用CMake生成对应平台的构建文件。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd assimp   # 进入Assimp源码目录</span><br><span class="line">mkdir build # 创建一个构建目录</span><br><span class="line">cd build    # 进入构建目录</span><br><span class="line">cmake ..    # 使用CMake生成构建文件</span><br></pre></td></tr></table></figure></li>
</ul>
<p>3.<strong>编译和安装:</strong></p>
<p>根据生成的构建文件进行编译和安装</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cmake --build . --config Release # 编译Release版本</span><br><span class="line">cmake --install .               # 安装Assimp</span><br></pre></td></tr></table></figure>

<p>4.<strong>集成到你的项目中</strong>：</p>
<ul>
<li>编译完成后，你可以将生成的Assimp库文件链接到你的项目中，并在你的代码中包含Assimp的头文件来使用其功能。</li>
</ul>
</li>
</ol>
<h2 id="如何配置和使用Assimp开源库？"><a href="#如何配置和使用Assimp开源库？" class="headerlink" title="如何配置和使用Assimp开源库？"></a>如何配置和使用Assimp开源库？</h2><p>完成编译后，你可以将生成的Assimp库文件链接到你的项目中，并在你的代码中包含Assimp的头文件来使用其功能。</p>
<ul>
<li><p><strong>链接库文件</strong>：将生成的Assimp静态库（<code>.a</code>, <code>.lib</code>）或动态库（<code>.so</code>, <code>.dll</code>）链接到你的项目中。</p>
</li>
<li><p><strong>包含头文件</strong>：在你的代码中包含Assimp的头文件来访问其API。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assimp/Importer.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assimp/scene.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assimp/postprocess.h&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>使用Assimp API导入和处理模型数据</p>
<p>使用Assimp的API来导入和处理3D模型数据，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个导入器</span></span><br><span class="line">Assimp::Importer importer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入模型文件到场景中</span></span><br><span class="line"><span class="type">const</span> aiScene* scene = importer.<span class="built_in">ReadFile</span>(<span class="string">&quot;path/to/your/model/file.obj&quot;</span>, aiProcess_Triangulate | aiProcess_FlipUVs);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode) &#123;</span><br><span class="line">    std::cerr &lt;&lt; <span class="string">&quot;Error: &quot;</span> &lt;&lt; importer.<span class="built_in">GetErrorString</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问场景中的节点和数据</span></span><br><span class="line">aiNode* rootNode = scene-&gt;mRootNode;</span><br><span class="line"><span class="comment">// 进一步处理节点、网格、材质等数据</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="学习Assimp开源库中数据结构的定义和类的设计"><a href="#学习Assimp开源库中数据结构的定义和类的设计" class="headerlink" title="学习Assimp开源库中数据结构的定义和类的设计"></a>学习Assimp开源库中数据结构的定义和类的设计</h2><p>主要数据结构和类</p>
<ol>
<li><strong>Assimp::Importer</strong>:<ul>
<li>导入器类，用于导入3D模型文件并转换为Assimp的数据结构。</li>
<li>提供了方法如<code>ReadFile</code>用于从文件读取数据，<code>GetScene</code>获取导入的场景数据等。</li>
</ul>
</li>
<li><strong>Assimp::Scene</strong>:<ul>
<li>场景类，表示一个完整的导入场景，包含所有的模型数据和相关信息。</li>
<li>可以访问场景中的所有节点、材质、纹理、动画等。</li>
</ul>
</li>
<li><strong>Assimp::Node</strong>:<ul>
<li>节点类，表示场景中的一个节点，通常对应于3D模型中的一个对象，如一个网格、灯光、相机等。</li>
<li>每个节点可以包含一个或多个Mesh对象。</li>
</ul>
</li>
<li><strong>Assimp::Mesh</strong>:<ul>
<li>网格类，表示一个网格对象，包含了顶点数据、面数据、UV坐标、法线等。</li>
<li>提供了方法如<code>GetVertexCount</code>获取顶点数量，<code>GetFaces</code>获取面数据等。</li>
</ul>
</li>
<li><strong>Assimp::Material</strong>:<ul>
<li>材质类，表示模型的材质信息，包括颜色、纹理、反射率等。</li>
<li>可以获取和设置材质属性，如<code>GetTextureCount</code>获取纹理数量，<code>GetColor</code>获取颜色信息等。</li>
</ul>
</li>
<li><strong>Assimp::Texture</strong>:<ul>
<li>纹理类，表示一个纹理对象，可以是Diffuse贴图、法线贴图等。</li>
<li>提供了方法如<code>GetWidth</code>和<code>GetHeight</code>获取纹理的宽度和高度等。</li>
</ul>
</li>
<li><strong>Assimp::Animation</strong>:<ul>
<li>动画类，表示模型的动画数据，包括关键帧信息、骨骼动画等。</li>
<li>可以获取动画的时间轴，关键帧的位移和旋转等。</li>
</ul>
</li>
<li><strong>Assimp::Bone</strong>:<ul>
<li>骨骼类，表示模型的骨骼信息，用于骨骼动画。</li>
<li>包含骨骼名称、骨骼的权重和偏移矩阵等信息。</li>
</ul>
</li>
</ol>
<h1 id="任务三、数据结构定义"><a href="#任务三、数据结构定义" class="headerlink" title="任务三、数据结构定义"></a><strong>任务三、数据结构定义</strong></h1><p> 根据开发项目的任务要求和功能设置，列出可能需要定义的数据结构，如基础的数学工具类：向量、矩阵、四元数等，几何元素：顶点、多边形、对象模型等，以及场景对象、场景图、场景图节点、包围盒等信息。</p>
<h2 id="如何用C-语言定义上面的数据结构。"><a href="#如何用C-语言定义上面的数据结构。" class="headerlink" title="如何用C++语言定义上面的数据结构。"></a>如何用C++语言定义上面的数据结构。</h2><p>参考一下开源库中的数据结构定义，如Assimp库</p>
<ol>
<li>用C++语言实现必要的数据结构。</li>
<li>定义结构体或者类，包含必要的属性和方法。</li>
</ol>
<p>向量类（Vector）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vector类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">float</span> _x = <span class="number">0.0f</span>, <span class="type">float</span> _y = <span class="number">0.0f</span>, <span class="type">float</span> _z = <span class="number">0.0f</span>)</span><br><span class="line">        : <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y), <span class="built_in">z</span>(_z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量加法</span></span><br><span class="line">    Vector <span class="keyword">operator</span>+(<span class="type">const</span> Vector&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x + other.x, y + other.y, z + other.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量减法</span></span><br><span class="line">    Vector <span class="keyword">operator</span>-(<span class="type">const</span> Vector&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(x - other.x, y - other.y, z - other.z);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量点积</span></span><br><span class="line">    <span class="function"><span class="type">float</span> <span class="title">dot</span><span class="params">(<span class="type">const</span> Vector&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * other.x + y * other.y + z * other.z;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向量叉积</span></span><br><span class="line">    <span class="function">Vector <span class="title">cross</span><span class="params">(<span class="type">const</span> Vector&amp; other)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Vector</span>(</span><br><span class="line">            y * other.z - z * other.y,</span><br><span class="line">            z * other.x - x * other.z,</span><br><span class="line">            x * other.y - y * other.x</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>矩阵类（Matrix）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Matrix类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Matrix</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> data[<span class="number">4</span>][<span class="number">4</span>]; <span class="comment">// 4x4矩阵，用于变换</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Matrix</span>() &#123;</span><br><span class="line">        <span class="built_in">memset</span>(data, <span class="number">0</span>, <span class="built_in">sizeof</span>(data));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 矩阵乘法</span></span><br><span class="line">    Matrix <span class="keyword">operator</span>*(<span class="type">const</span> Matrix&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        Matrix result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; ++j) &#123;</span><br><span class="line">                result.data[i][j] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    result.data[i][j] += data[i][k] * other.data[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取单位矩阵</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Matrix <span class="title">identity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Matrix result;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            result.data[i][i] = <span class="number">1.0f</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>四元数类（Quaternion）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Quaternion类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Quaternion</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">float</span> w, x, y, z;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Quaternion</span>(<span class="type">float</span> _w = <span class="number">1.0f</span>, <span class="type">float</span> _x = <span class="number">0.0f</span>, <span class="type">float</span> _y = <span class="number">0.0f</span>, <span class="type">float</span> _z = <span class="number">0.0f</span>)</span><br><span class="line">        : <span class="built_in">w</span>(_w), <span class="built_in">x</span>(_x), <span class="built_in">y</span>(_y), <span class="built_in">z</span>(_z) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四元数乘法</span></span><br><span class="line">    Quaternion <span class="keyword">operator</span>*(<span class="type">const</span> Quaternion&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Quaternion</span>(</span><br><span class="line">            w * other.w - x * other.x - y * other.y - z * other.z,</span><br><span class="line">            w * other.x + x * other.w + y * other.z - z * other.y,</span><br><span class="line">            w * other.y - x * other.z + y * other.w + z * other.x,</span><br><span class="line">            w * other.z + x * other.y - y * other.x + z * other.w</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 四元数插值</span></span><br><span class="line">    <span class="function"><span class="type">static</span> Quaternion <span class="title">lerp</span><span class="params">(<span class="type">const</span> Quaternion&amp; q1, <span class="type">const</span> Quaternion&amp; q2, <span class="type">float</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="type">float</span> cosTheta = q<span class="number">1.</span>x * q<span class="number">2.</span>x + q<span class="number">1.</span>y * q<span class="number">2.</span>y + q<span class="number">1.</span>z * q<span class="number">2.</span>z + q<span class="number">1.</span>w * q<span class="number">2.</span>w;</span><br><span class="line">        <span class="type">float</span> k0, k1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果两个四元数夹角足够小，使用线性插值</span></span><br><span class="line">        <span class="keyword">if</span> (cosTheta &gt; <span class="number">0.9995f</span>) &#123;</span><br><span class="line">            k0 = <span class="number">1.0f</span> - t;</span><br><span class="line">            k1 = t;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">float</span> theta = <span class="built_in">acosf</span>(cosTheta);</span><br><span class="line">            <span class="type">float</span> sinTheta = <span class="built_in">sinf</span>(theta);</span><br><span class="line">            k0 = <span class="built_in">sinf</span>((<span class="number">1.0f</span> - t) * theta) / sinTheta;</span><br><span class="line">            k1 = <span class="built_in">sinf</span>(t * theta) / sinTheta;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Quaternion</span>(</span><br><span class="line">            k0 * q<span class="number">1.</span>w + k1 * q<span class="number">2.</span>w,</span><br><span class="line">            k0 * q<span class="number">1.</span>x + k1 * q<span class="number">2.</span>x,</span><br><span class="line">            k0 * q<span class="number">1.</span>y + k1 * q<span class="number">2.</span>y,</span><br><span class="line">            k0 * q<span class="number">1.</span>z + k1 * q<span class="number">2.</span>z</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>顶点类（Vertex）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Vertex类定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span> &#123;</span><br><span class="line">    Vector position;</span><br><span class="line">    Vector normal;</span><br><span class="line">    Vector texCoords;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Vertex</span>(<span class="type">const</span> Vector&amp; _position, <span class="type">const</span> Vector&amp; _normal, <span class="type">const</span> Vector&amp; _texCoords)</span><br><span class="line">        : <span class="built_in">position</span>(_position), <span class="built_in">normal</span>(_normal), <span class="built_in">texCoords</span>(_texCoords) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>多边形类（Polygon）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Polygon类定义</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Polygon</span> &#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vertexIndices; <span class="comment">// 顶点索引</span></span><br><span class="line">    Vector normal;                  <span class="comment">// 多边形法线</span></span><br><span class="line">    Vector texCoords;               <span class="comment">// 多边形的纹理坐标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">Polygon</span>(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; _vertexIndices, <span class="type">const</span> Vector&amp; _normal, <span class="type">const</span> Vector&amp; _texCoords)</span><br><span class="line">        : <span class="built_in">vertexIndices</span>(_vertexIndices), <span class="built_in">normal</span>(_normal), <span class="built_in">texCoords</span>(_texCoords) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象模型类（ObjectModel）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ObjectModel类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectModel</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;Mesh&gt; meshes;</span><br><span class="line">    std::vector&lt;Material&gt; materials;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">ObjectModel</span>(<span class="type">const</span> std::vector&lt;Mesh&gt;&amp; _meshes, <span class="type">const</span> std::vector&lt;Material&gt;&amp; _materials)</span><br><span class="line">        : <span class="built_in">meshes</span>(_meshes), <span class="built_in">materials</span>(_materials) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>场景对象类（SceneObject）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SceneObject类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneObject</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;ObjectModel&gt; models;</span><br><span class="line">    Vector position;</span><br><span class="line">    Quaternion rotation;</span><br><span class="line">    Vector scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SceneObject</span>(<span class="type">const</span> std::vector&lt;ObjectModel&gt;&amp; _models, <span class="type">const</span> Vector&amp; _position, <span class="type">const</span> Quaternion&amp; _rotation, <span class="type">const</span> Vector&amp; _scale)</span><br><span class="line">        : <span class="built_in">models</span>(_models), <span class="built_in">position</span>(_position), <span class="built_in">rotation</span>(_rotation), <span class="built_in">scale</span>(_scale) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>场景图节点类（SceneNode）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SceneNode类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SceneNode</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SceneObject object;</span><br><span class="line">    std::vector&lt;SceneNode&gt; children;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">SceneNode</span>(<span class="type">const</span> SceneObject&amp; _object)</span><br><span class="line">        : <span class="built_in">object</span>(_object) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加子节点</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addChild</span><span class="params">(<span class="type">const</span> SceneNode&amp; child)</span> </span>&#123;</span><br><span class="line">        children.<span class="built_in">push_back</span>(child);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>包围盒类（BoundingBox）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BoundingBox类定义</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BoundingBox</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector min;</span><br><span class="line">    Vector max;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="built_in">BoundingBox</span>(<span class="type">const</span> Vector&amp; _min, <span class="type">const</span> Vector&amp; _max)</span><br><span class="line">        : <span class="built_in">min</span>(_min), <span class="built_in">max</span>(_max) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="Assimp库中几个重要的数据结构"><a href="#Assimp库中几个重要的数据结构" class="headerlink" title="Assimp库中几个重要的数据结构"></a>Assimp库中几个重要的数据结构</h2><p>aiVector3D</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">aiVector3D</span> &#123;</span><br><span class="line">    <span class="type">float</span> x, y, z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>用于表示三维向量，包含了<code>x</code>、<code>y</code>、<code>z</code>三个成员变量，用于表示位置、法线等。</p>
<p>aiMatrix4x4</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">aiMatrix4x4</span> &#123;</span><br><span class="line">    <span class="type">float</span> a1, a2, a3, a4;</span><br><span class="line">    <span class="type">float</span> b1, b2, b3, b4;</span><br><span class="line">    <span class="type">float</span> c1, c2, c3, c4;</span><br><span class="line">    <span class="type">float</span> d1, d2, d3, d4;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表示一个4x4的变换矩阵，用于进行模型的变换（旋转、缩放、平移等）。</p>
<p>aiQuaternion</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">aiQuaternion</span> &#123;</span><br><span class="line">    <span class="type">float</span> w, x, y, z;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表示四元数，用于表示旋转变换。</p>
<p>aiMesh</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">aiMesh</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> mNumVertices; <span class="comment">// 顶点数量</span></span><br><span class="line">    aiVector3D* mVertices; <span class="comment">// 顶点数组</span></span><br><span class="line">    <span class="comment">// 其他成员变量如mNormals、mTextureCoords等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表示一个网格对象，包含了顶点数据、法线数据、UV坐标等信息。</p>
<p>aiMaterial</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">aiMaterial</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    aiString mTextures[NUM_TEXTURES]; <span class="comment">// 纹理路径数组</span></span><br><span class="line">    <span class="comment">// 其他成员变量如mColors、mShininess等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表示一个材质对象，包含了材质的纹理、颜色、反射率等信息。</p>
<p>aiNode</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">aiNode</span> &#123;</span><br><span class="line">    aiString mName; <span class="comment">// 节点名称</span></span><br><span class="line">    aiMatrix4x4 mTransformation; <span class="comment">// 节点的变换矩阵</span></span><br><span class="line">    aiNode* mParent; <span class="comment">// 父节点指针</span></span><br><span class="line">    std::vector&lt;aiNode*&gt; mChildren; <span class="comment">// 子节点列表</span></span><br><span class="line">    std::vector&lt;aiMesh*&gt; mMeshes; <span class="comment">// 该节点包含的网格列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>表示一个场景图中的节点，包含了节点的名称、变换矩阵、父子节点关系等信息。</p>
<h1 id="任务四、场景信息管理"><a href="#任务四、场景信息管理" class="headerlink" title="任务四、场景信息管理"></a><strong>任务四、场景信息管理</strong></h1><h2 id="什么是QT？"><a href="#什么是QT？" class="headerlink" title="什么是QT？"></a>什么是QT？</h2><p>Qt是一个跨平台的C++应用程序开发框架，最初由挪威的Trolltech公司开发。它提供了丰富的工具集和类库，用于开发图形用户界面（GUI）应用程序、2D&#x2F;3D图形处理、网络通信、文件操作等各种应用。</p>
<p><strong>跨平台性</strong>：Qt提供了一套统一的API，使得开发者可以在不同的操作系统（如Windows、macOS、Linux等）上编写一次代码，然后进行编译即可在多个平台上运行。</p>
<p><strong>丰富的类库</strong>：Qt包含了大量的模块和类库，涵盖了从基础的数据结构、容器，到高级的GUI组件、OpenGL集成，甚至包括了数据库连接、XML处理等功能。</p>
<p><strong>信号与槽机制</strong>：Qt引入了信号与槽机制（Signals and Slots），用于对象间的通信，使得开发者可以更加灵活和简洁地处理事件和数据流。</p>
<p><strong>开发效率</strong>：Qt的设计目标之一是提升开发效率，通过良好的文档和示例、可视化开发工具（如Qt Creator），帮助开发者快速构建复杂的应用程序。</p>
<p><strong>商业友好</strong>：Qt采用了双重许可证模型，开发者可以选择LGPL或商业许可证，使得Qt既适合开源项目，也适合商业应用开发。</p>
<p><strong>模块化和可扩展性</strong>：Qt被设计为模块化的框架，允许开发者根据需要选择性地集成和使用各种模块，同时支持扩展和定制。</p>
<p>Qt广泛应用于各种领域的软件开发，包括但不限于：</p>
<ul>
<li>桌面应用程序</li>
<li>移动应用程序（如安卓、iOS）</li>
<li>嵌入式系统</li>
<li>游戏开发</li>
<li>自动化和控制系统</li>
<li>数据可视化和科学计算</li>
</ul>
<h2 id="QT有哪些核心功能？"><a href="#QT有哪些核心功能？" class="headerlink" title="QT有哪些核心功能？"></a>QT有哪些核心功能？</h2><p><strong>图形用户界面（GUI）开发</strong>：</p>
<ul>
<li>Qt提供了丰富的GUI组件和控件，包括按钮、文本框、列表框、表格、菜单、工具栏等，能够满足各种复杂界面的构建需求。</li>
</ul>
<p><strong>图形和绘图</strong>：</p>
<ul>
<li>Qt支持2D和3D绘图，提供了绘图类和API，包括基本的绘制操作、路径绘制、图像操作等，同时集成了OpenGL和Vulkan等图形API，支持高性能的图形渲染。</li>
</ul>
<p><strong>事件处理和信号与槽机制</strong>：</p>
<ul>
<li>Qt引入了信号与槽机制（Signals and Slots），是其核心的事件处理机制，使得对象间的通信更加简洁和灵活。</li>
</ul>
<p><strong>文件和网络操作</strong>：</p>
<ul>
<li>Qt提供了跨平台的文件系统操作和网络通信功能，包括文件读写、网络请求、Socket编程等，支持多种协议和安全连接。</li>
</ul>
<p><strong>多媒体处理</strong>：</p>
<ul>
<li>Qt包含了音频和视频播放、录制和处理的类库，支持多种格式和编解码器，适用于多媒体应用开发。</li>
</ul>
<p><strong>数据库访问</strong>：</p>
<ul>
<li>Qt集成了SQL模块，支持与主流数据库系统（如MySQL、SQLite、PostgreSQL等）的连接和操作，提供了高层次的API进行数据管理和查询。</li>
</ul>
<p><strong>并发和多线程</strong>：</p>
<ul>
<li>Qt提供了线程类和并发编程框架，简化了多线程编程的复杂性，包括线程间通信、同步和互斥等机制。</li>
</ul>
<p><strong>国际化和本地化</strong>：</p>
<ul>
<li>Qt支持国际化和本地化功能，能够轻松实现多语言界面的开发和管理，包括文本翻译、日期时间格式化、货币处理等。</li>
</ul>
<p><strong>XML和JSON处理</strong>：</p>
<ul>
<li>Qt提供了XML和JSON解析和生成的类库，便于处理和交换结构化数据。</li>
</ul>
<p><strong>Web引擎集成</strong>：</p>
<ul>
<li>Qt内置了Web引擎模块，支持Web内容的显示和交互，包括基于WebKit的浏览器功能。</li>
</ul>
<p><strong>高级图形效果和动画</strong>：</p>
<ul>
<li>Qt提供了丰富的动画和效果类，支持过渡效果、缓动动画和定制的图形效果，增强用户界面的交互性和视觉吸引力。</li>
</ul>
<p><strong>测试和调试工具</strong>：</p>
<ul>
<li>Qt包含了用于自动化测试和调试的工具和框架，帮助开发者提高代码质量和应用程序稳定性。</li>
</ul>
<h2 id="QT的下载、安装与配置方法。"><a href="#QT的下载、安装与配置方法。" class="headerlink" title="QT的下载、安装与配置方法。"></a>QT的下载、安装与配置方法。</h2><p>下载Qt</p>
<ol>
<li><strong>访问Qt官网</strong>：打开 Qt 官网 <a target="_blank" rel="noopener" href="https://www.qt.io/">https://www.qt.io/</a>。</li>
<li><strong>选择适合版本</strong>：Qt 提供了不同版本，包括开源版和商业版。根据你的需求选择合适的版本。</li>
<li><strong>下载安装程序</strong>：点击下载按钮，选择对应操作系统的安装程序。Qt 支持 Windows、macOS 和各种 Linux 发行版。</li>
</ol>
<p>安装Qt</p>
<p>在 Windows 上安装 Qt</p>
<ol>
<li><strong>运行安装程序</strong>：双击下载的安装程序（<code>.exe</code> 文件），跟随安装向导进行操作。</li>
<li><strong>选择安装组件</strong>：根据需要选择安装的组件，通常包括 Qt Creator（Qt 的集成开发环境）和相应的 Qt 版本（如 Qt 5 或 Qt 6）。</li>
<li><strong>选择安装路径</strong>：设置安装路径，建议选择默认路径以简化后续配置。</li>
<li><strong>完成安装</strong>：完成安装过程，Qt Creator 会自动集成在安装目录中。</li>
</ol>
<p>配置 Qt</p>
<ol>
<li><strong>启动 Qt Creator</strong>：安装完成后，启动 Qt Creator。</li>
<li><strong>配置编译工具</strong>：Qt Creator 通常会自动检测已安装的编译工具链（如 GCC 或 Clang）。如果需要，可以在 Tools -&gt; Options -&gt; Kits 中添加或修改编译工具链。</li>
<li><strong>配置 Qt 版本</strong>：在 Tools -&gt; Options -&gt; Kits 中配置 Qt 版本，确保选择了正确的 Qt 版本。</li>
<li><strong>创建和配置项目</strong>：使用 Qt Creator 创建新项目或打开现有项目，并在项目属性中配置 Qt 版本和其他依赖。</li>
<li><strong>编译和运行</strong>：在 Qt Creator 中编译和运行项目，确保一切设置正确。</li>
</ol>
<h2 id="QT中的界面元素。"><a href="#QT中的界面元素。" class="headerlink" title="QT中的界面元素。"></a>QT中的界面元素。</h2><p>基本控件（Basic Widgets）</p>
<ol>
<li>QWidget<ul>
<li>所有可视窗口部件的基类，可以容纳子部件。</li>
</ul>
</li>
<li>QLabel<ul>
<li>用于显示文本或图像标签。</li>
</ul>
</li>
<li>QPushButton<ul>
<li>按钮控件，用于触发操作或事件。</li>
</ul>
</li>
<li>QCheckBox<ul>
<li>复选框，用于表示二进制状态的选择。</li>
</ul>
</li>
<li>QRadioButton<ul>
<li>单选按钮，用于从一组中选择一个选项。</li>
</ul>
</li>
<li>QLineEdit<ul>
<li>单行文本编辑框，用于输入和显示单行文本。</li>
</ul>
</li>
<li>QTextEdit<ul>
<li>多行文本编辑框，用于输入和显示多行文本。</li>
</ul>
</li>
<li>QComboBox<ul>
<li>下拉框，用于从预定义列表中选择一个选项。</li>
</ul>
</li>
<li>QSpinBox和 QDoubleSpinBox<ul>
<li>数字输入框，分别用于整数和浮点数的输入。</li>
</ul>
</li>
</ol>
<p>布局管理器（Layout Managers）</p>
<ol>
<li><strong>QVBoxLayout</strong> 和 <strong>QHBoxLayout</strong>：<ul>
<li>垂直布局和水平布局管理器，用于管理控件的排列方式。</li>
</ul>
</li>
<li><strong>QGridLayout</strong>：<ul>
<li>网格布局管理器，用于将控件组织成行和列的网格形式。</li>
</ul>
</li>
<li><strong>QFormLayout</strong>：<ul>
<li>表单布局管理器，用于管理表单控件的排列方式，通常用于标签和输入框的配对。</li>
</ul>
</li>
</ol>
<p>高级视图组件（Advanced Views）</p>
<ol>
<li><strong>QTableView</strong>：<ul>
<li>表格视图，用于显示二维表格数据。</li>
</ul>
</li>
<li><strong>QTreeView</strong> 和 <strong>QListView</strong>：<ul>
<li>树形视图和列表视图，用于显示层级数据和列表数据。</li>
</ul>
</li>
<li><strong>QGraphicsView</strong>：<ul>
<li>图形视图框架，支持自定义的绘图和图形操作。</li>
</ul>
</li>
</ol>
<p>其他常用元素</p>
<ol>
<li><strong>QMenuBar</strong> 和 <strong>QMenu</strong>：<ul>
<li>菜单栏和菜单，用于实现应用程序的菜单系统。</li>
</ul>
</li>
<li><strong>QToolBar</strong>：<ul>
<li>工具栏，通常包含快捷操作按钮或菜单项。</li>
</ul>
</li>
<li><strong>QStatusBar</strong>：<ul>
<li>状态栏，用于显示应用程序的状态信息或临时消息。</li>
</ul>
</li>
<li><strong>QDockWidget</strong>：<ul>
<li>可停靠窗口小部件，可以在主窗口中停靠或浮动。</li>
</ul>
</li>
</ol>
<p>自定义控件和视图</p>
<p>除了以上提到的内置控件和视图，Qt 还支持开发者自定义控件和视图，通过继承现有的 Qt 类或者实现自定义的绘制和交互逻辑，可以创建符合特定需求的界面元素。</p>
<h2 id="QT中如何实现菜单、工具条、对话框等。"><a href="#QT中如何实现菜单、工具条、对话框等。" class="headerlink" title="QT中如何实现菜单、工具条、对话框等。"></a>QT中如何实现菜单、工具条、对话框等。</h2><p>实现菜单（Menu）</p>
<p>Qt 使用 <code>QMenu</code> 和 <code>QMenuBar</code> 类来创建菜单。以下是创建菜单的基本步骤：</p>
<ol>
<li><strong>创建菜单栏和菜单项</strong>：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建菜单栏</span></span><br><span class="line">QMenuBar *menuBar = <span class="keyword">new</span> <span class="built_in">QMenuBar</span>(<span class="keyword">this</span>);</span><br><span class="line"><span class="built_in">setMenuBar</span>(menuBar);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建文件菜单</span></span><br><span class="line">QMenu *fileMenu = menuBar-&gt;<span class="built_in">addMenu</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;File&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加菜单项</span></span><br><span class="line">QAction *openAct = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Open...&quot;</span>), <span class="keyword">this</span>, &amp;MyMainWindow::openFile);</span><br><span class="line">QAction *saveAct = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;&amp;Save&quot;</span>), <span class="keyword">this</span>, &amp;MyMainWindow::saveFile);</span><br><span class="line">fileMenu-&gt;<span class="built_in">addSeparator</span>(); <span class="comment">// 添加分隔线</span></span><br><span class="line">QAction *exitAct = fileMenu-&gt;<span class="built_in">addAction</span>(<span class="built_in">tr</span>(<span class="string">&quot;E&amp;xit&quot;</span>), <span class="keyword">this</span>, &amp;QMainWindow::close);</span><br></pre></td></tr></table></figure>

<p>这段代码创建了一个主窗口（<code>MyMainWindow</code>），并在菜单栏中添加了一个名为 “File” 的菜单，包含打开、保存和退出等菜单项。</p>
<p><strong>处理菜单项的动作</strong>：</p>
<ul>
<li><code>addAction</code> 方法用于向菜单中添加动作（<code>QAction</code>），指定菜单项的文本和对应的动作槽函数（如 <code>openFile</code> 和 <code>saveFile</code>）。</li>
</ul>
<p>实现工具条（Toolbars）</p>
<p>Qt 使用 <code>QToolBar</code> 类来创建工具条。以下是创建工具条的基本步骤：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QToolBar *toolbar = <span class="built_in">addToolBar</span>(<span class="built_in">tr</span>(<span class="string">&quot;Main Toolbar&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加工具按钮</span></span><br><span class="line">toolbar-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/open.png&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Open&quot;</span>), <span class="keyword">this</span>, &amp;MyMainWindow::openFile);</span><br><span class="line">toolbar-&gt;<span class="built_in">addAction</span>(<span class="built_in">QIcon</span>(<span class="string">&quot;:/images/save.png&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Save&quot;</span>), <span class="keyword">this</span>, &amp;MyMainWindow::saveFile);</span><br></pre></td></tr></table></figure>

<p>这段代码在主窗口中添加了一个名为 “Main Toolbar” 的工具条，并向工具条中添加了 “Open” 和 “Save” 的工具按钮，分别关联了 <code>openFile</code> 和 <code>saveFile</code> 槽函数。</p>
<p>实现对话框（Dialogs）</p>
<p>Qt 提供了多种对话框类来实现常见的用户交互需求，如文件选择、消息提示、输入框等。</p>
<ol>
<li><p><strong>文件对话框</strong>（打开文件对话框示例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">QString fileName = QFileDialog::<span class="built_in">getOpenFileName</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Open File&quot;</span>), QDir::<span class="built_in">homePath</span>(), <span class="built_in">tr</span>(<span class="string">&quot;Text Files (*.txt);;All Files (*)&quot;</span>));</span><br><span class="line"><span class="keyword">if</span> (!fileName.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 打开文件操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>消息框</strong>（消息提示框示例）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line">QMessageBox::<span class="built_in">information</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Information&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Operation completed successfully.&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>使用 <code>QMessageBox</code> 类创建信息提示框，显示操作成功的消息。</p>
<p><strong>输入对话框</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line">QString text = QInputDialog::<span class="built_in">getText</span>(<span class="keyword">this</span>, <span class="built_in">tr</span>(<span class="string">&quot;Input Dialog&quot;</span>), <span class="built_in">tr</span>(<span class="string">&quot;Enter your name:&quot;</span>), QLineEdit::Normal, <span class="built_in">QString</span>(), &amp;ok);</span><br><span class="line"><span class="keyword">if</span> (ok &amp;&amp; !text.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">    <span class="comment">// 处理输入的文本</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 <code>QInputDialog</code> 类创建输入对话框，获取用户输入的文本。</p>
<h2 id="QT中如何处理鼠标、键盘事件？其原理是什么？"><a href="#QT中如何处理鼠标、键盘事件？其原理是什么？" class="headerlink" title="QT中如何处理鼠标、键盘事件？其原理是什么？"></a>QT中如何处理鼠标、键盘事件？其原理是什么？</h2><p>处理鼠标事件</p>
<p>Qt 中处理鼠标事件的步骤通常涉及以下几个关键点：</p>
<ol>
<li><p><strong>重写事件处理函数</strong>：在你的自定义部件（如继承自 <code>QWidget</code> 或 <code>QMainWindow</code> 的类）中，重写对应的事件处理函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::mousePressEvent</span><span class="params">(QMouseEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理鼠标按下事件</span></span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Mouse Pressed at: &quot;</span> &lt;&lt; event-&gt;<span class="built_in">pos</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里重写了 <code>mousePressEvent</code> 函数，用于处理鼠标按下事件。Qt 提供了多种鼠标事件处理函数，如 <code>mousePressEvent</code>、<code>mouseReleaseEvent</code>、<code>mouseMoveEvent</code> 等，分别用于处理鼠标按下、释放和移动等事件。</p>
</li>
<li><p><strong>安装事件过滤器</strong>：如果需要对特定部件或对象的事件进行拦截和处理，可以安装事件过滤器。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">// 在构造函数中安装事件过滤器</span></span><br><span class="line">MyWidget::<span class="built_in">MyWidget</span>(QWidget *parent) : <span class="built_in">QWidget</span>(parent) &#123;</span><br><span class="line">    <span class="comment">// 安装事件过滤器</span></span><br><span class="line">    <span class="built_in">installEventFilter</span>(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 事件过滤器函数</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">MyWidget::eventFilter</span><span class="params">(QObject *obj, QEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj == <span class="keyword">this</span> &amp;&amp; event-&gt;<span class="built_in">type</span>() == QEvent::MouseButtonPress) &#123;</span><br><span class="line">        QMouseEvent *mouseEvent = <span class="built_in">static_cast</span>&lt;QMouseEvent *&gt;(event);</span><br><span class="line">        <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;Event filtered: Mouse Pressed at&quot;</span> &lt;&lt; mouseEvent-&gt;<span class="built_in">pos</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 表示事件已被处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 其他事件交由默认处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，通过重写 <code>eventFilter</code> 函数实现事件过滤器，捕获并处理鼠标按下事件。</p>
</li>
</ol>
<p>处理键盘事件</p>
<p>处理键盘事件的步骤类似于处理鼠标事件，也是通过重写事件处理函数或安装事件过滤器来实现。</p>
<ol>
<li><p><strong>重写事件处理函数</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">MyWidget::keyPressEvent</span><span class="params">(QKeyEvent *event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理键盘按下事件</span></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;<span class="built_in">key</span>() == Qt::Key_Escape) &#123;</span><br><span class="line">        <span class="built_in">close</span>(); <span class="comment">// 按下 ESC 键关闭窗口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述例子中，重写了 <code>keyPressEvent</code> 函数，用于处理键盘按下事件。Qt 提供了多种键盘事件处理函数，如 <code>keyPressEvent</code>、<code>keyReleaseEvent</code> 等。</p>
</li>
<li><p><strong>安装事件过滤器</strong>：</p>
<p>与处理鼠标事件类似，可以安装事件过滤器来捕获和处理特定对象的键盘事件。</p>
</li>
</ol>
<p>原理</p>
<p>Qt 的事件处理机制基于事件分发和响应的设计模式。当用户操作（如鼠标点击、键盘按键）发生时，Qt 会将对应的事件封装为 <code>QEvent</code> 对象，并将其发送给目标对象。目标对象根据事件类型（如鼠标事件、键盘事件）调用对应的事件处理函数（如 <code>mousePressEvent</code>、<code>keyPressEvent</code>），从而完成事件的处理逻辑。</p>
<h1 id="任务五、场景可视化"><a href="#任务五、场景可视化" class="headerlink" title="任务五、场景可视化"></a>任务五、场景可视化</h1><h2 id="什么是OpenGL？"><a href="#什么是OpenGL？" class="headerlink" title="什么是OpenGL？"></a>什么是OpenGL？</h2><p>OpenGL（Open Graphics Library）是一个跨平台的图形编程接口，用于开发二维、三维图形应用程序。它提供了一套用于渲染复杂图形的标准化方法，支持硬件加速的图形渲染，可以在各种操作系统（如Windows、macOS、Linux）上运行。</p>
<p>主要特点和功能包括：</p>
<ol>
<li><strong>跨平台性</strong>：OpenGL 是跨平台的，可以在不同的操作系统上运行，并与硬件图形加速器兼容。</li>
<li><strong>硬件加速</strong>：OpenGL 可以利用图形硬件加速渲染，利用显卡的图形处理能力来提高渲染性能。</li>
<li><strong>开放标准</strong>：OpenGL 是开放标准，由Khronos Group组织制定和管理，提供了一致的接口和功能集，使得开发者可以跨平台开发图形应用程序。</li>
<li><strong>功能丰富</strong>：OpenGL 提供了丰富的图形功能和渲染技术，包括基本的几何图形绘制、光照、纹理映射、深度测试、多重采样等高级图形效果。</li>
<li><strong>可扩展性</strong>：OpenGL 提供了可扩展性，允许开发者通过扩展（Extensions）来访问和利用新的硬件特性和图形技术。</li>
</ol>
<p>应用领域</p>
<p>OpenGL 在计算机图形学、游戏开发、虚拟现实（VR）、增强现实（AR）、科学可视化、工程设计、医学图像处理等领域得到广泛应用。它为开发者提供了强大的工具和接口，使得复杂的图形渲染任务变得可行和高效。</p>
<h2 id="OpenGL有哪些核心功能？"><a href="#OpenGL有哪些核心功能？" class="headerlink" title="OpenGL有哪些核心功能？"></a>OpenGL有哪些核心功能？</h2><p><strong>基本几何图形绘制</strong>：</p>
<ul>
<li>绘制点、线段和三角形等基本几何图形。</li>
</ul>
<p><strong>顶点和片元处理</strong>：</p>
<ul>
<li>定义顶点数据和片元（像素）处理，包括顶点着色器和片元着色器的编程。</li>
</ul>
<p><strong>变换和投影</strong>：</p>
<ul>
<li>实现模型视图变换（Model-View Transform）和投影变换（Projection Transform），控制对象的位置、方向和视角。</li>
</ul>
<p><strong>纹理映射</strong>：</p>
<ul>
<li>加载、管理和应用纹理图像，实现贴图效果，包括多重纹理和立方体映射等。</li>
</ul>
<p><strong>光照和材质</strong>：</p>
<ul>
<li>模拟光照效果，包括环境光、漫反射光和镜面光，定义材质属性如光泽度和反射率。</li>
</ul>
<p><strong>深度测试和蒙版测试</strong>：</p>
<ul>
<li>控制像素的可见性和绘制顺序，实现深度排序和遮挡关系。</li>
</ul>
<p><strong>帧缓冲和渲染缓冲</strong>：</p>
<ul>
<li>管理和操作帧缓冲（Frame Buffer）和渲染缓冲，实现离屏渲染、多重采样和后期处理效果。</li>
</ul>
<p><strong>多边形剔除和裁剪</strong>：</p>
<ul>
<li>基于视点位置和投影平面裁剪不可见的几何图元，优化渲染性能。</li>
</ul>
<p><strong>顶点缓冲对象（VBO）和索引缓冲对象（IBO）</strong>：</p>
<ul>
<li>通过 VBO 存储和管理顶点数据，通过 IBO 存储和管理顶点索引，优化顶点数据的传输和使用效率。</li>
</ul>
<p><strong>着色语言</strong>：</p>
<ul>
<li>使用高级的着色语言（如GLSL，OpenGL Shading Language）编写顶点和片元着色器，实现复杂的图形效果和计算。</li>
</ul>
<h2 id="如何实现在visual-studio工程中使用OpenGL绘图。"><a href="#如何实现在visual-studio工程中使用OpenGL绘图。" class="headerlink" title="如何实现在visual studio工程中使用OpenGL绘图。"></a>如何实现在visual studio工程中使用OpenGL绘图。</h2><p>步骤概述</p>
<ol>
<li><strong>安装 OpenGL 开发环境</strong>：<ul>
<li>确保系统中安装了 OpenGL 的开发环境。通常情况下，Windows 平台需要安装 OpenGL 的实现库，如 Mesa3D 或者专门的显卡驱动（如 NVIDIA 或 AMD 的显卡驱动）。</li>
</ul>
</li>
<li><strong>创建 Visual Studio 项目</strong>：<ul>
<li>打开 Visual Studio，创建一个新的空项目或选择现有项目。</li>
</ul>
</li>
<li><strong>配置项目属性</strong>：<ul>
<li>设置项目属性，包括包含 OpenGL 头文件目录和链接 OpenGL 库文件。</li>
</ul>
</li>
<li><strong>编写和编译 OpenGL 代码</strong>：<ul>
<li>编写 OpenGL 的初始化代码和绘图代码，并确保能够正确编译和链接。</li>
</ul>
</li>
</ol>
<p>具体步骤</p>
<ol>
<li>安装 OpenGL 实现</li>
</ol>
<p>如果系统中没有安装 OpenGL 实现库，可以考虑以下选项之一：</p>
<ul>
<li><strong>使用 Mesa3D</strong>：Mesa3D 是一个开源的 OpenGL 实现，可以在 Windows 上使用。可以从 <a target="_blank" rel="noopener" href="https://www.mesa3d.org/">Mesa3D 官网</a> 下载安装。</li>
<li><strong>使用显卡驱动</strong>：大多数显卡厂商（如 NVIDIA、AMD）的官方显卡驱动都包含了 OpenGL 的支持。安装最新的显卡驱动即可。</li>
</ul>
<ol start="2">
<li>创建 Visual Studio 项目</li>
</ol>
<ul>
<li>打开 Visual Studio，选择创建一个新的空项目或者使用现有项目。</li>
</ul>
<ol start="3">
<li>配置项目属性</li>
</ol>
<ul>
<li>右键点击项目，选择 “属性”。</li>
<li>在属性对话框中，进行以下设置：<ul>
<li><strong>VC++ 目录 -&gt; 包含目录</strong>：添加 OpenGL 的头文件目录。通常包含在 OpenGL SDK 或者 Mesa3D 安装目录下的 <code>include</code> 文件夹中。</li>
<li><strong>VC++ 目录 -&gt; 库目录</strong>：添加 OpenGL 的库文件目录。通常包含在 OpenGL SDK 或者 Mesa3D 安装目录下的 <code>lib</code> 文件夹中。</li>
<li><strong>链接器 -&gt; 输入 -&gt; 附加依赖项</strong>：添加 OpenGL 的库文件。常见的库文件包括 <code>opengl32.lib</code>。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>编写和编译 OpenGL 代码</li>
</ol>
<ul>
<li><p>在项目中创建或打开一个源文件（如 <code>main.cpp</code>）。</p>
</li>
<li><p>编写基本的 OpenGL 初始化和绘图代码。以下是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line">    <span class="built_in">glBegin</span>(GL_POLYGON);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line">    <span class="built_in">glFlush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;OpenGL Test&quot;</span>);</span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);</span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个示例使用了 GLUT（OpenGL Utility Toolkit）库来创建窗口和处理显示函数，GLUT 是一个方便的工具库，可以简化 OpenGL 窗口和事件处理的实现</p>
</li>
</ul>
<h1 id="任务六、动画功能实现"><a href="#任务六、动画功能实现" class="headerlink" title="任务六、动画功能实现"></a><strong>任务六、动画功能实现</strong></h1><h2 id="平移、旋转、缩放等基本动画功能实现的原理，数学表示。"><a href="#平移、旋转、缩放等基本动画功能实现的原理，数学表示。" class="headerlink" title="平移、旋转、缩放等基本动画功能实现的原理，数学表示。"></a>平移、旋转、缩放等基本动画功能实现的原理，数学表示。</h2><p>平移（Translation）</p>
<p><strong>原理</strong>：平移是将对象沿着指定的方向移动一定的距离。在二维空间中，平移操作可以简单地理解为将对象的每个点 <code>(x, y)</code> 沿着 <code>(dx, dy)</code> 方向移动，即从 <code>(x, y)</code> 变为 <code>(x + dx, y + dy)</code>。</p>
<p><strong>数学表示</strong>：在二维和三维空间中，平移可以用一个平移矩阵来表示：</p>
<ul>
<li><strong>二维空间</strong>：1 &amp; 0 &amp; dx \0 &amp; 1 &amp; dy \0 &amp; 0 &amp; 1\end{bmatrix} ]其中 <code>(dx, dy)</code> 是平移的位移量。</li>
<li><strong>三维空间</strong>：1 &amp; 0 &amp; 0 &amp; dx \0 &amp; 1 &amp; 0 &amp; dy \0 &amp; 0 &amp; 1 &amp; dz \0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} ]其中 <code>(dx, dy, dz)</code> 是平移的位移量。</li>
</ul>
<ol start="2">
<li>旋转（Rotation）</li>
</ol>
<p><strong>原理</strong>：旋转是围绕一个固定点或轴将对象绕其旋转一定角度。在二维空间中，绕原点逆时针旋转角度为 <code>θ</code> 的变换可以通过旋转矩阵来实现。</p>
<p><strong>数学表示</strong>：在二维空间中，逆时针旋转角度为 <code>θ</code> 的旋转矩阵为：</p>
<p>\cos(\theta) &amp; -\sin(\theta) &amp; 0 \\sin(\theta) &amp; \cos(\theta) &amp; 0 \0 &amp; 0 &amp; 1\end{bmatrix} ]顺时针旋转角度为 <code>θ</code> 的旋转矩阵为：[ R &#x3D; \begin{bmatrix}\cos(\theta) &amp; \sin(\theta) &amp; 0 \-\sin(\theta) &amp; \cos(\theta) &amp; 0 \0 &amp; 0 &amp; 1\end{bmatrix} ]### 3. 缩放（Scaling）<strong>原理</strong>：缩放是按比例改变对象的大小。在二维空间中，缩放因子 <code>(sx, sy)</code> 分别沿 x 和 y 方向缩放对象。<strong>数学表示</strong>：在二维和三维空间中，缩放可以用缩放矩阵来表示：- <strong>二维空间</strong>：[ S &#x3D; \begin{bmatrix}sx &amp; 0 &amp; 0 \0 &amp; sy &amp; 0 \0 &amp; 0 &amp; 1\end{bmatrix} ]- <strong>三维空间</strong>：[ S &#x3D; \begin{bmatrix}sx &amp; 0 &amp; 0 &amp; 0 \0 &amp; sy &amp; 0 &amp; 0 \0 &amp; 0 &amp; sz &amp; 0 \0 &amp; 0 &amp; 0 &amp; 1\end{bmatrix} ]其中 <code>(sx, sy, sz)</code> 是沿各个轴的缩放因子。### 数学表示的应用这些基本的变换操作通常通过矩阵乘法来组合应用到对象的顶点或顶点集合上。例如，要实现先缩放、再旋转、最后平移的变换效果，可以将这些变换矩阵按顺序相乘，然后应用到对象的顶点坐标上。这些数学表示和原理为实现图形动画提供了基础，通过正确应用变换矩阵，可以实现复杂的对象运动、变形和动画效果。</p>
<h2 id="在开发的应用软件中添加交互功能，让用户实现动画的配置。"><a href="#在开发的应用软件中添加交互功能，让用户实现动画的配置。" class="headerlink" title="在开发的应用软件中添加交互功能，让用户实现动画的配置。"></a>在开发的应用软件中添加交互功能，让用户实现动画的配置。</h2><p>设计用户界面（UI）</p>
<p>首先，设计一个直观和易于使用的用户界面，让用户能够配置动画参数和选项。可以考虑使用以下 UI 元素：</p>
<ul>
<li><strong>滑块（Slider）</strong>：用于调整动画的时间、速度或其他参数。</li>
<li><strong>复选框（Checkbox）</strong>：启用或禁用动画的不同部分或效果。</li>
<li><strong>下拉列表（Dropdown）</strong>：选择不同的动画类型或预设。</li>
<li><strong>按钮（Button）</strong>：触发动画的播放、暂停、重置等操作。</li>
<li><strong>文本输入框（Text Input）</strong>：输入特定数值或参数。</li>
<li><strong>画布（Canvas）或预览窗口</strong>：显示动画效果的预览。</li>
</ul>
<ol start="2">
<li>实现交互逻辑</li>
</ol>
<p>使用选定的编程语言和图形库（如 Qt、OpenGL 等），实现用户界面的交互逻辑。以下是一些常见的实现步骤：</p>
<ul>
<li><strong>响应用户操作</strong>：监听用户在 UI 元素上的交互事件，例如滑块值的变化、按钮的点击等。</li>
<li><strong>更新动画参数</strong>：根据用户的输入或操作更新动画的参数，例如动画的速度、方向、缩放等。</li>
<li><strong>控制动画播放</strong>：编写代码控制动画的播放、暂停、停止和重置操作。</li>
<li><strong>与动画引擎集成</strong>：如果使用现有的动画引擎或库（如 Unity、Three.js 等），则需要编写代码以与该引擎进行集成和交互。</li>
</ul>
<ol start="3">
<li>实时预览和反馈</li>
</ol>
<p>为了增强用户体验，可以提供实时预览功能，让用户可以在配置动画参数时即时看到效果。这可以通过在 UI 中嵌入一个实时更新的画布或预览窗口来实现。</p>
<ol start="4">
<li>错误处理和用户反馈</li>
</ol>
<p>确保在用户输入不正确或操作无效时提供适当的错误处理和反馈机制。例如，显示提示消息或警告，以帮助用户正确配置动画参数。</p>
<p>示例代码片段</p>
<p>以下是一个简单的伪代码片段，演示如何在 Qt 中实现动画配置的基本交互：</p>
<p>设计用户界面（UI）</p>
<p>首先，设计一个直观和易于使用的用户界面，让用户能够配置动画参数和选项。可以考虑使用以下 UI 元素：</p>
<ul>
<li><strong>滑块（Slider）</strong>：用于调整动画的时间、速度或其他参数。</li>
<li><strong>复选框（Checkbox）</strong>：启用或禁用动画的不同部分或效果。</li>
<li><strong>下拉列表（Dropdown）</strong>：选择不同的动画类型或预设。</li>
<li><strong>按钮（Button）</strong>：触发动画的播放、暂停、重置等操作。</li>
<li><strong>文本输入框（Text Input）</strong>：输入特定数值或参数。</li>
<li><strong>画布（Canvas）或预览窗口</strong>：显示动画效果的预览。</li>
</ul>
<ol start="2">
<li>实现交互逻辑</li>
</ol>
<p>使用选定的编程语言和图形库（如 Qt、OpenGL 等），实现用户界面的交互逻辑。以下是一些常见的实现步骤：</p>
<ul>
<li><strong>响应用户操作</strong>：监听用户在 UI 元素上的交互事件，例如滑块值的变化、按钮的点击等。</li>
<li><strong>更新动画参数</strong>：根据用户的输入或操作更新动画的参数，例如动画的速度、方向、缩放等。</li>
<li><strong>控制动画播放</strong>：编写代码控制动画的播放、暂停、停止和重置操作。</li>
<li><strong>与动画引擎集成</strong>：如果使用现有的动画引擎或库（如 Unity、Three.js 等），则需要编写代码以与该引擎进行集成和交互。</li>
</ul>
<ol start="3">
<li>实时预览和反馈</li>
</ol>
<p>为了增强用户体验，可以提供实时预览功能，让用户可以在配置动画参数时即时看到效果。这可以通过在 UI 中嵌入一个实时更新的画布或预览窗口来实现。</p>
<ol start="4">
<li>错误处理和用户反馈</li>
</ol>
<p>确保在用户输入不正确或操作无效时提供适当的错误处理和反馈机制。例如，显示提示消息或警告，以帮助用户正确配置动画参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">// 定义一个滑块和一个按钮</span></span><br><span class="line">QSlider *speedSlider = <span class="keyword">new</span> <span class="built_in">QSlider</span>(Qt::Horizontal);</span><br><span class="line">QPushButton *playButton = <span class="keyword">new</span> <span class="built_in">QPushButton</span>(<span class="string">&quot;播放&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接滑块数值变化的信号到槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(speedSlider, &amp;QSlider::valueChanged, [&amp;](<span class="type">int</span> value) &#123;</span><br><span class="line">    <span class="comment">// 更新动画的速度或其他参数</span></span><br><span class="line">    animation.<span class="built_in">setSpeed</span>(value);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接按钮的点击信号到槽函数</span></span><br><span class="line"><span class="built_in">connect</span>(playButton, &amp;QPushButton::clicked, [&amp;]() &#123;</span><br><span class="line">    <span class="keyword">if</span> (animation.<span class="built_in">isPlaying</span>()) &#123;</span><br><span class="line">        animation.<span class="built_in">pause</span>();</span><br><span class="line">        playButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;播放&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        animation.<span class="built_in">play</span>();</span><br><span class="line">        playButton-&gt;<span class="built_in">setText</span>(<span class="string">&quot;暂停&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 UI 元素添加到布局或窗口中，并显示</span></span><br></pre></td></tr></table></figure>



<h2 id="利用C-和OpenGL实现动画效果预览。"><a href="#利用C-和OpenGL实现动画效果预览。" class="headerlink" title="利用C++和OpenGL实现动画效果预览。"></a>利用C++和OpenGL实现动画效果预览。</h2><p>设置开发环境</p>
<p>确保你的开发环境中已经配置好了 OpenGL。你可能需要安装 OpenGL 的开发库和头文件，并设置好编译环境（如 Visual Studio 或者使用 CMake 进行项目配置）。</p>
<ol start="2">
<li>编写基础框架代码</li>
</ol>
<p>创建一个基本的 OpenGL 应用程序框架，用于初始化 OpenGL 窗口、设置视口（Viewport）和处理用户输入。以下是一个简单的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span>  <span class="comment">// 使用 GLUT 库，注意根据实际情况调整头文件引入</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClearColor</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 设置背景颜色为黑色</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在此处绘制你的动画对象或场景</span></span><br><span class="line">    <span class="comment">// 示例：绘制一个简单的旋转三角形</span></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);    <span class="comment">// 设置颜色为红色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);    <span class="comment">// 设置颜色为绿色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);    <span class="comment">// 设置颜色为蓝色</span></span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glFlush</span>();  <span class="comment">// 清空绘制缓冲区</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB);  <span class="comment">// 单缓冲、RGB颜色模式</span></span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">500</span>, <span class="number">500</span>);  <span class="comment">// 窗口大小</span></span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;OpenGL Animation Preview&quot;</span>);  <span class="comment">// 创建窗口并设置标题</span></span><br><span class="line">    <span class="built_in">init</span>();  <span class="comment">// 初始化 OpenGL</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);  <span class="comment">// 注册显示回调函数</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutMainLoop</span>();  <span class="comment">// 进入主循环，处理事件和渲染</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现动画效果</li>
</ol>
<p>要实现动画效果，通常涉及到更新对象的位置、旋转角度或其他属性，并在每帧中重新绘制场景。以下是实现简单旋转动画的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">cpp</span><br><span class="line">复制代码</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;GL/glut.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> angle = <span class="number">0.0</span>;  <span class="comment">// 初始化旋转角度</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    angle += <span class="number">1.0</span>;  <span class="comment">// 更新旋转角度</span></span><br><span class="line">    <span class="keyword">if</span> (angle &gt; <span class="number">360.0</span>) &#123;</span><br><span class="line">        angle -= <span class="number">360.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutPostRedisplay</span>();  <span class="comment">// 请求重新绘制窗口</span></span><br><span class="line">    <span class="built_in">glutTimerFunc</span>(<span class="number">16</span>, update, <span class="number">0</span>);  <span class="comment">// 设置下一帧更新的定时器（约 60 FPS）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glClear</span>(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glLoadIdentity</span>();  <span class="comment">// 重置模型视图矩阵</span></span><br><span class="line">    <span class="built_in">glRotatef</span>(angle, <span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);  <span class="comment">// 绕 z 轴旋转 angle 度</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glBegin</span>(GL_TRIANGLES);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">1.0</span>, <span class="number">0.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">-0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">1.0</span>, <span class="number">0.0</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.5</span>, <span class="number">-0.5</span>);</span><br><span class="line">    <span class="built_in">glColor3f</span>(<span class="number">0.0</span>, <span class="number">0.0</span>, <span class="number">1.0</span>);</span><br><span class="line">    <span class="built_in">glVertex2f</span>(<span class="number">0.0</span>, <span class="number">0.5</span>);</span><br><span class="line">    <span class="built_in">glEnd</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glFlush</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">glutInit</span>(&amp;argc, argv);</span><br><span class="line">    <span class="built_in">glutInitDisplayMode</span>(GLUT_SINGLE | GLUT_RGB);</span><br><span class="line">    <span class="built_in">glutInitWindowSize</span>(<span class="number">500</span>, <span class="number">500</span>);</span><br><span class="line">    <span class="built_in">glutCreateWindow</span>(<span class="string">&quot;OpenGL Animation Preview&quot;</span>);</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutDisplayFunc</span>(display);</span><br><span class="line">    <span class="built_in">glutTimerFunc</span>(<span class="number">0</span>, update, <span class="number">0</span>);  <span class="comment">// 启动定时器进行动画更新</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">glutMainLoop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们使用 <code>glRotatef</code> 函数在每一帧中绕 z 轴旋转一个角度，从而实现了一个简单的旋转动画。<code>glutTimerFunc</code> 函数用于设置定时器，在每次更新时调用 <code>update</code> 函数。</p>
<ol start="4">
<li>扩展和优化</li>
</ol>
<ul>
<li><strong>使用变换矩阵</strong>：对于复杂的动画效果，可以使用 OpenGL 提供的变换矩阵（如 <code>glTranslatef</code>、<code>glScalef</code> 等）来控制对象的平移、缩放和旋转。</li>
<li><strong>使用帧缓冲对象（FBO）</strong>：用于实现后期处理效果或渲染到纹理，提升渲染效率和视觉效果。</li>
<li><strong>优化性能</strong>：避免在每帧中重新计算固定的数据或状态，尽可能减少 CPU 和 GPU 资源的使用。</li>
</ul>
<h2 id="C-脚本文件的定义。"><a href="#C-脚本文件的定义。" class="headerlink" title="C#脚本文件的定义。"></a>C#脚本文件的定义。</h2><p>假设我们要编写一个简单的 C# 脚本，计算并输出两个数字的和。创建一个名为 <code>ScriptExample.cs</code> 的文件，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScriptExample</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="type">static</span> <span class="type">void</span> <span class="title">Main</span><span class="params">(string[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> num1 = <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> num2 = <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> sum = num1 + num2;</span><br><span class="line"></span><br><span class="line">        Console.<span class="built_in">WriteLine</span>(<span class="string">&quot;The sum of &#123;0&#125; and &#123;1&#125; is &#123;2&#125;&quot;</span>, num1, num2, sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<ol>
<li>**命名空间引用 (using)**：<code>using System;</code> 声明了代码中要使用的命名空间。在这里，<code>System</code> 命名空间包含了 C# 核心库，例如 <code>Console</code> 类。</li>
<li>**类定义 (public class ScriptExample)**：定义了一个名为 <code>ScriptExample</code> 的公共类。</li>
<li>**主方法 (Main)**：<code>Main</code> 方法是 C# 程序的入口点，它接受一个 <code>string[]</code> 类型的参数 <code>args</code>，表示命令行参数。在这个例子中，我们没有使用 <code>args</code> 参数。</li>
<li><strong>变量和计算</strong>：在 <code>Main</code> 方法中，我们定义了两个整数变量 <code>num1</code> 和 <code>num2</code>，并计算它们的和，并将结果赋给 <code>sum</code> 变量。</li>
<li><strong>输出结果</strong>：使用 <code>Console.WriteLine</code> 方法输出结果到控制台。这里使用了格式化字符串 <code>&#123;0&#125;</code>, <code>&#123;1&#125;</code>, <code>&#123;2&#125;</code> 来显示变量的值。</li>
</ol>
<p>使用 C# 脚本文件</p>
<p>要运行这个脚本文件，你可以使用任何支持 .NET 运行时的环境，比如 Visual Studio、Visual Studio Code 或者通过命令行编译运行。</p>
<p>在命令行中，可以使用以下命令编译和运行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bash</span><br><span class="line">复制代码</span><br><span class="line">csc ScriptExample.cs  # 编译脚本文件</span><br><span class="line">ScriptExample.exe     # 运行生成的可执行文件</span><br></pre></td></tr></table></figure>

<p>在 Visual Studio 或 Visual Studio Code 中，可以直接打开文件并运行，它们会自动处理编译和执行过程。</p>
<h2 id="如何在Unity中定义和使用C-脚本。"><a href="#如何在Unity中定义和使用C-脚本。" class="headerlink" title="如何在Unity中定义和使用C#脚本。"></a>如何在Unity中定义和使用C#脚本。</h2><ol>
<li><p><strong>创建新的 C# 脚本</strong>：</p>
<ul>
<li>在 Unity 的项目视图中，右键点击 Assets 文件夹或其子文件夹。</li>
<li>选择 <code>Create</code> -&gt; <code>C# Script</code>。</li>
<li>输入脚本名称，例如 <code>MyScript</code>，然后按 Enter 键创建脚本。</li>
</ul>
</li>
<li><p><strong>编辑脚本</strong>：</p>
<ul>
<li>双击新创建的脚本文件，可以在默认的集成开发环境 (IDE) 中（如 Visual Studio 或 Visual Studio Code）打开。</li>
<li>编写你的 C# 代码。例如，一个简单的脚本可能是这样的：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyScript</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Start is called before the first frame update</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Debug.<span class="built_in">Log</span>(<span class="string">&quot;Hello, Unity!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update is called once per frame</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 在 Update 方法中添加游戏逻辑，每帧执行一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，<code>MyScript</code> 继承自 <code>MonoBehaviour</code> 类，这是所有 Unity 脚本的基类，提供了与 Unity 引擎交互所需的方法和功能。</p>
</li>
</ol>
<p>将脚本附加到游戏对象</p>
<ol>
<li><strong>将脚本附加到游戏对象</strong>：<ul>
<li>在 Unity 的场景视图或层次视图中选择一个游戏对象（如空对象、Cube、Sphere 等）。</li>
<li>在 Inspector 视图中，将创建的脚本（如 <code>MyScript</code>）拖放到选定的游戏对象上，或者点击 <code>Add Component</code> 按钮搜索并添加脚本。</li>
</ul>
</li>
<li><strong>编辑脚本属性</strong>：<ul>
<li>在 Inspector 视图中，你可以看到附加的脚本组件，并可以调整公共字段或属性，例如修改某个变量的值，来影响游戏对象的行为。</li>
</ul>
</li>
</ol>
<p>运行和调试</p>
<ol>
<li><strong>运行游戏</strong>：<ul>
<li>在 Unity 编辑器中，点击上方的 <code>Play</code> 按钮来运行游戏并测试脚本效果。</li>
</ul>
</li>
<li><strong>调试脚本</strong>：<ul>
<li>如果需要调试脚本，可以在代码中使用 <code>Debug.Log</code> 输出调试信息，或者使用 IDE 的调试器来单步执行和检查变量值。</li>
</ul>
</li>
</ol>
<p>事件方法说明</p>
<ul>
<li><strong>Start 方法</strong>：在脚本被加载后第一帧更新之前调用，适合用于初始化设置。</li>
<li><strong>Update 方法</strong>：每一帧都会调用一次，用于处理需要每帧更新的逻辑，如移动、检测输入等。</li>
<li><strong>其他事件方法</strong>：还有像 <code>Awake</code>、<code>OnEnable</code>、<code>OnDisable</code>、<code>FixedUpdate</code>、<code>LateUpdate</code> 等方法，用于特定的生命周期事件或物理更新事件。</li>
</ul>
<h2 id="用户定义的动画转换为C-脚本文件的方法。"><a href="#用户定义的动画转换为C-脚本文件的方法。" class="headerlink" title="用户定义的动画转换为C#脚本文件的方法。"></a>用户定义的动画转换为C#脚本文件的方法。</h2><p> 1.创建动画</p>
<p>首先，在 Unity 中创建用户定义的动画。这可以通过使用 Unity 的动画系统来实现，例如使用 Animation 或 Animator 组件来创建和编辑动画剪辑。</p>
<ol start="2">
<li>导出动画</li>
</ol>
<p>如果用户定义的动画是在 Unity 内部创建的（使用 Animation 或 Animator 组件），则无需导出，直接在 Unity 中使用即可。</p>
<p>如果用户定义的动画是在外部工具（如 Blender、Maya 等）中创建的，需要将动画导入到 Unity 中。在导入过程中，Unity 会将动画转换为其内部的动画剪辑格式。</p>
<ol start="3">
<li>创建C#脚本文件</li>
</ol>
<p>接下来，需要创建一个 C# 脚本文件，用于控制和管理动画的播放和触发逻辑。</p>
<ol>
<li><p>在 Unity 的项目视图中，右键点击 Assets 文件夹或其子文件夹。</p>
</li>
<li><p>选择 <code>Create</code> -&gt; <code>C# Script</code>。</p>
</li>
<li><p>输入脚本名称，例如 <code>AnimationController</code>，然后按 Enter 键创建脚本。</p>
</li>
<li><p>编写脚本</p>
</li>
</ol>
<p>打开刚刚创建的 C# 脚本文件，并编辑脚本以添加动画控制逻辑。以下是一个示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AnimationController</span> : MonoBehaviour</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 引用动画组件</span></span><br><span class="line">    <span class="keyword">public</span> Animation animation;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start 方法用于初始化</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Start</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 获取动画组件的引用</span></span><br><span class="line">        animation = <span class="built_in">GetComponent</span>&lt;Animation&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 播放名为 &quot;UserAnimation&quot; 的动画</span></span><br><span class="line">        animation.<span class="built_in">Play</span>(<span class="string">&quot;UserAnimation&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update 方法每帧调用一次</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Update</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 在 Update 中可以添加根据条件播放动画的逻辑</span></span><br><span class="line">        <span class="keyword">if</span> (Input.<span class="built_in">GetKeyDown</span>(KeyCode.Space))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 播放名为 &quot;UserAnimation2&quot; 的动画</span></span><br><span class="line">            animation.<span class="built_in">Play</span>(<span class="string">&quot;UserAnimation2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>将脚本附加到游戏对象</li>
</ol>
<p>将刚刚创建的脚本组件附加到一个游戏对象上，该游戏对象应该具有包含用户定义动画的 Animation 或 Animator 组件。</p>
<ol start="6">
<li>调试和测试</li>
</ol>
<p>在 Unity 编辑器中运行游戏，观察动画的播放效果，并确保脚本按预期控制动画的播放和转换。</p>
<ol start="7">
<li>扩展和优化</li>
</ol>
<p>根据需要，可以在脚本中添加更多的逻辑，如动画事件的监听、参数控制等，以实现更复杂的动画行为。</p>
<h1 id="任务七、交互设计模块"><a href="#任务七、交互设计模块" class="headerlink" title="任务七、交互设计模块"></a><strong>任务七、交互设计模块</strong></h1><h2 id="碰撞检测的概念。"><a href="#碰撞检测的概念。" class="headerlink" title="碰撞检测的概念。"></a>碰撞检测的概念。</h2><p>碰撞检测（Collision Detection）是指在计算机图形学和游戏开发中，用于检测两个或多个物体是否相交或碰撞的过程。在游戏和模拟应用中，碰撞检测是实现物体间交互和反应的关键技术之一。</p>
<p>概述</p>
<p>碰撞检测通常涉及以下几个方面：</p>
<ol>
<li><strong>碰撞体（Collision Shapes）</strong>：每个物体通常都有一个或多个碰撞体来描述其形状和大小。碰撞体可以是简单的几何形状（如球体、盒子、圆柱体等），也可以是复杂的网格（如网格碰撞体），用来精确地描述物体的形状。</li>
<li><strong>碰撞检测算法</strong>：用于判断两个碰撞体是否相交或碰撞的算法。常见的碰撞检测算法包括：<ul>
<li><strong>基于包围体（Bounding Volume）的检测</strong>：使用简单的包围体（如轴对齐包围盒、球体等）来快速排除不可能相交的物体，然后进行更精确的检测。</li>
<li><strong>精确碰撞检测</strong>：对两个物体的碰撞体进行精确的几何计算，例如点与包围盒、线段与球体、球体与三角形网格等。</li>
</ul>
</li>
<li><strong>碰撞响应</strong>：当检测到碰撞时，通常需要执行相应的处理，例如：<ul>
<li>修改物体的位置、速度或旋转，以模拟物理反应。</li>
<li>触发游戏中的事件或动画。</li>
<li>计分或处理游戏逻辑。</li>
</ul>
</li>
</ol>
<p>应用</p>
<p>在游戏开发中，碰撞检测是实现以下功能的关键：</p>
<ul>
<li><strong>玩家与环境的交互</strong>：例如角色与墙壁、门、道具等的碰撞。</li>
<li><strong>物体之间的互动</strong>：例如子弹与敌人、车辆之间的碰撞。</li>
<li><strong>物理仿真</strong>：例如模拟刚体之间的碰撞和反弹。</li>
<li><strong>碰撞避免</strong>：例如 AI 控制的对象避免与障碍物相撞。</li>
</ul>
<p>实现</p>
<p>在 Unity 或其他游戏引擎中，通常提供了现成的碰撞检测系统和工具，开发者可以使用这些系统来快速实现碰撞检测功能。在 Unity 中，可以通过以下方式实现碰撞检测：</p>
<ul>
<li><p><strong>Collider 组件</strong>：每个物体可以附加不同类型的碰撞体组件，例如 BoxCollider、SphereCollider、MeshCollider 等。</p>
</li>
<li><p><strong>物理引擎</strong>：Unity 内置了物理引擎（例如 NVIDIA PhysX），可以通过 Rigidbody 组件和碰撞器一起使用，实现更真实的物理交互和碰撞检测。</p>
</li>
</ul>
<h2 id="碰撞检测方法。"><a href="#碰撞检测方法。" class="headerlink" title="碰撞检测方法。"></a>碰撞检测方法。</h2><p>基于包围体的碰撞检测</p>
<p>这种方法使用简单的包围体（Bounding Volume）来快速排除不可能相交的物体，然后进行更精确的检测。</p>
<ul>
<li>**轴对齐包围盒 (AABB)**：AABB 是一个与坐标轴平行的矩形或立方体，可以用来包围物体。两个 AABB 的碰撞检测可以通过比较它们的最小和最大顶点来进行快速判断。</li>
<li><strong>球体包围盒</strong>：球体也是一种简单的包围体形状，可以用来包围物体，特别是对于环形物体的碰撞检测。</li>
</ul>
<ol start="2">
<li>精确碰撞检测方法</li>
</ol>
<p>精确碰撞检测方法可以更准确地判断物体之间的碰撞，但通常计算量较大，适合于需要更高精度的场景。</p>
<ul>
<li><strong>点与包围体的碰撞检测</strong>：例如判断一个点是否在一个包围盒内。</li>
<li><strong>线段与球体、盒子等的碰撞检测</strong>：例如判断一条线段与一个球体或盒子是否相交。</li>
<li><strong>三角形网格之间的碰撞检测</strong>：对于复杂的物体形状，可以使用三角形网格进行碰撞检测，判断两个三角形网格是否相交。</li>
</ul>
<ol start="3">
<li>几何算法</li>
</ol>
<p>在某些情况下，可以利用几何算法直接计算物体之间的交点或相交区域，从而判断碰撞。</p>
<ul>
<li>**分离轴定理 (Separating Axis Theorem, SAT)**：SAT 是一种用于判断两个凸多边形或凸体是否相交的方法，通过检查它们是否有分离的轴来进行判断。</li>
<li><strong>Minkowski 求和</strong>：Minkowski 求和可以将碰撞检测问题转化为几何形状相交的问题，适用于复杂的碰撞检测场景。</li>
</ul>
<ol start="4">
<li>物理引擎支持</li>
</ol>
<p>许多游戏引擎（如 Unity、Unreal Engine）内置了物理引擎，提供了高效的碰撞检测和物理仿真功能。开发者可以通过设置物理材质、刚体属性和碰撞器来管理物体之间的碰撞关系，而无需手动实现碰撞检测算法。</p>
<p>实现注意事项</p>
<ul>
<li><p><strong>性能优化</strong>：在实现碰撞检测时，要考虑到计算量和性能消耗。选择合适的碰撞检测方法和数据结构可以有效提升性能。</p>
</li>
<li><p><strong>碰撞体选择</strong>：根据实际需求选择合适的碰撞体类型（如盒子、球体、网格碰撞体等），以平衡精确度和性能。</p>
</li>
<li><p><strong>算法复杂度</strong>：理解每种碰撞检测算法的时间复杂度和空间复杂度，根据场景特点选择合适的算法实现。</p>
</li>
</ul>
<h2 id="碰撞检测的具体实现。"><a href="#碰撞检测的具体实现。" class="headerlink" title="碰撞检测的具体实现。"></a>碰撞检测的具体实现。</h2><p>碰撞检测的具体实现通常依赖于所使用的游戏引擎或编程环境。在游戏开发中，常见的实现方式涉及到基本的碰撞体、算法选择、以及物理引擎的使用。下面我将简要介绍一种常见的碰撞检测实现方法，适用于使用 Unity 引擎的情况。</p>
<p>在 Unity 中的碰撞检测实现</p>
<p>在 Unity 中，碰撞检测通常通过以下步骤实现：</p>
<ol>
<li><p><strong>添加碰撞体组件</strong>：</p>
<ul>
<li>对于需要进行碰撞检测的物体，需要附加相应的碰撞体组件。常见的碰撞体包括 BoxCollider、SphereCollider、MeshCollider 等，具体选择取决于物体的形状和需求。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="comment">// 例如，在代码中添加一个 BoxCollider 组件：</span></span><br><span class="line">GameObject cube = GameObject.<span class="built_in">CreatePrimitive</span>(PrimitiveType.Cube);</span><br><span class="line">cube.<span class="built_in">AddComponent</span>&lt;BoxCollider&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>处理碰撞事件</strong>：</p>
<ul>
<li>在 Unity 中，可以通过触发器（Trigger）和物理碰撞来检测物体之间的碰撞。</li>
<li><strong>使用 OnCollisionEnter 方法处理碰撞</strong>：当物体碰撞时，Unity 调用 OnCollisionEnter 方法。可以在脚本中实现 OnCollisionEnter 方法来响应碰撞事件。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnCollisionEnter</span><span class="params">(Collision collision)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理碰撞事件</span></span><br><span class="line">    Debug.<span class="built_in">Log</span>(<span class="string">&quot;Collision with: &quot;</span> + collision.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>使用 OnTriggerEnter 方法处理触发器碰撞</strong>：如果希望检测物体是否进入了触发器区域，可以使用 OnTriggerEnter 方法。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">OnTriggerEnter</span><span class="params">(Collider other)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理触发器碰撞事件</span></span><br><span class="line">    Debug.<span class="built_in">Log</span>(<span class="string">&quot;Trigger enter with: &quot;</span> + other.gameObject.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>物理引擎支持</strong>：</p>
<ul>
<li>Unity 内置了物理引擎（通常是 NVIDIA PhysX），可以处理物体之间的物理交互和碰撞检测。在使用物理引擎时，Unity 会自动处理物体的碰撞检测和碰撞响应。</li>
</ul>
</li>
<li><p><strong>碰撞体属性和设置</strong>：</p>
<ul>
<li>可以在 Unity 的 Inspector 视图中设置碰撞体的属性，例如碰撞体的大小、形状、是否为触发器等。这些设置可以影响碰撞检测的精度和行为。</li>
</ul>
</li>
</ol>
<p>示例</p>
<p>下面是一个简单的示例，演示了如何在 Unity 中使用碰撞检测：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CollisionExample</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnCollisionEnter</span>(<span class="params">Collision collision</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出碰撞的物体名称</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;Collision with: &quot;</span> + collision.gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">OnTriggerEnter</span>(<span class="params">Collider other</span>)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出触发器碰撞的物体名称</span></span><br><span class="line">        Debug.Log(<span class="string">&quot;Trigger enter with: &quot;</span> + other.gameObject.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，当物体发生碰撞或进入触发器时，将会在控制台输出碰撞或触发器碰撞的物体名称。</p>
<h2 id="如何实现物体的拾取？"><a href="#如何实现物体的拾取？" class="headerlink" title="如何实现物体的拾取？"></a>如何实现物体的拾取？</h2><p>实现物体的拾取（Picking）是指玩家能够通过鼠标或触摸输入选择和操作游戏场景中的物体。以下是在 Unity 中实现物体拾取的基本方法：</p>
<ol>
<li>射线检测法（Raycast）</li>
</ol>
<p>射线检测是一种常见且有效的方法，用于从相机发射一条射线，然后检测射线与场景中物体的交点，从而确定玩家所点击的物体。</p>
<p>实现步骤：</p>
<ol>
<li><p><strong>编写拾取脚本</strong>：</p>
<figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">csharp</span><br><span class="line">复制代码</span><br><span class="line"><span class="keyword">using</span> UnityEngine;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ObjectPicker</span> : <span class="title">MonoBehaviour</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Update</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测鼠标左键点击</span></span><br><span class="line">        <span class="keyword">if</span> (Input.GetMouseButtonDown(<span class="number">0</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发射一条射线从鼠标点击位置</span></span><br><span class="line">            Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);</span><br><span class="line">            RaycastHit hit;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 检测是否击中物体</span></span><br><span class="line">            <span class="keyword">if</span> (Physics.Raycast(ray, <span class="keyword">out</span> hit))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 获取击中的物体</span></span><br><span class="line">                GameObject selectedObject = hit.collider.gameObject;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 在这里可以对选中的物体进行操作</span></span><br><span class="line">                Debug.Log(<span class="string">&quot;Selected object: &quot;</span> + selectedObject.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>理解代码</strong>：</p>
<ul>
<li><code>Input.GetMouseButtonDown(0)</code> 检测鼠标左键是否按下。</li>
<li><code>Camera.main.ScreenPointToRay(Input.mousePosition)</code> 创建一条从主摄像机经过鼠标点击位置的射线。</li>
<li><code>Physics.Raycast(ray, out hit)</code> 检测射线是否与物体碰撞，并返回碰撞信息到 <code>hit</code> 变量。</li>
<li><code>hit.collider.gameObject</code> 获取碰撞的物体。</li>
</ul>
</li>
<li><p><strong>附加脚本</strong>：</p>
<ul>
<li>将这个脚本附加到能够被点击和选择的物体上，如角色、道具等，确保射线能够与其碰撞检测。</li>
</ul>
</li>
<li><p>其他实现方法</p>
</li>
</ol>
<p>除了射线检测法外，还有其他实现物体拾取的方法，如使用触发器（Trigger）或物理交互。</p>
<ul>
<li><strong>触发器拾取</strong>：通过设置触发器（Collider 的 IsTrigger 属性）来检测物体进入触发区域，并响应触发器事件来实现拾取。</li>
<li><strong>物理交互</strong>：使用物理引擎的碰撞体和刚体组件，例如给物体添加 Rigidbody 组件，并在 OnCollisionEnter 方法中处理物体碰撞来实现交互。</li>
</ul>
<p>注意事项</p>
<ul>
<li><strong>性能优化</strong>：射线检测是一种计算密集型操作，尤其是在大型场景中或频繁使用时。考虑使用物理层级、射线的最大长度等来优化性能。</li>
<li><strong>多个物体检测</strong>：如果场景中有多个可以被拾取的物体，可以使用层级过滤器或物体标签来区分和筛选目标物体。</li>
</ul>
<h1 id="任务八、Unity工程生成"><a href="#任务八、Unity工程生成" class="headerlink" title="任务八、Unity工程生成"></a><strong>任务八、Unity工程生成</strong></h1><h2 id="Unity工程文件的构成。"><a href="#Unity工程文件的构成。" class="headerlink" title="Unity工程文件的构成。"></a>Unity工程文件的构成。</h2><p>Unity 工程文件的构成主要包括以下几个核心部分，每个部分都对 Unity 的项目结构和功能起着重要作用：</p>
<ol>
<li>Assets 文件夹</li>
</ol>
<p>Assets 文件夹是 Unity 项目的核心，其中包含了所有项目所需的资源文件，如模型、纹理、音频、脚本等。这些资源文件可以通过 Unity 编辑器导入、创建和管理。</p>
<ol start="2">
<li>Project Settings 文件夹</li>
</ol>
<p>Project Settings 文件夹包含了项目的配置和设置文件，这些文件决定了项目在 Unity 编辑器中的行为和属性设置。其中一些关键文件包括：</p>
<ul>
<li><strong>ProjectSettings.asset</strong>：包含了整个项目的全局设置，如输入管理、引用解析器、编辑器界面布局等。</li>
<li><strong>QualitySettings.asset</strong>：包含了项目的质量设置，如图形质量、屏幕分辨率、抗锯齿等。</li>
<li><strong>EditorBuildSettings.asset</strong>：包含了项目的构建设置，如场景列表、目标平台、构建配置等。</li>
</ul>
<ol start="3">
<li>Library 文件夹</li>
</ol>
<p>Library 文件夹是 Unity 的缓存和中间文件目录，它包含了 Unity 引擎生成的临时数据和预编译数据，用于加快编辑器的加载和处理速度。这些文件通常不需要手动管理，Unity 编辑器会自动处理。</p>
<ol start="4">
<li>Packages 文件夹</li>
</ol>
<p>Packages 文件夹包含了项目使用的 Unity Package Manager（UPM）导入的包和依赖。这些包可以是 Unity 提供的官方包、第三方插件或自定义包。</p>
<ol start="5">
<li>ProjectSettings 文件夹</li>
</ol>
<p>ProjectSettings 文件夹包含了 Unity 项目的配置和设置文件。</p>
<h2 id="Unity工程文件夹的结构。"><a href="#Unity工程文件夹的结构。" class="headerlink" title="Unity工程文件夹的结构。"></a>Unity工程文件夹的结构。</h2><p>标准Unity工程文件夹结构</p>
<ol>
<li><strong>Assets 文件夹</strong>：<ul>
<li><strong>Resources</strong>：包含所有的资源文件，如模型、纹理、音频、脚本等。这些资源可以通过 Unity 编辑器管理和使用。</li>
</ul>
</li>
<li><strong>Library 文件夹</strong>：<ul>
<li><strong>Temp</strong>：存放临时文件，如代码编译生成的中间文件。</li>
<li><strong>ScriptAssemblies</strong>：存放编译生成的脚本程序集文件。</li>
<li><strong>CachedAssetImporters</strong>：缓存的资源导入器信息。</li>
<li><strong>CachedAssetState</strong>：缓存的资源状态信息。</li>
<li><strong>ShaderCache</strong>：存放编译生成的着色器缓存文件。</li>
<li><strong>assetDatabase3</strong>：Unity 的资源数据库文件。</li>
</ul>
</li>
<li><strong>ProjectSettings 文件夹</strong>：<ul>
<li><strong>ProjectSettings.asset</strong>：包含了项目的全局设置，如输入管理、引用解析器、编辑器界面布局等。</li>
<li><strong>QualitySettings.asset</strong>：包含了项目的质量设置，如图形质量、屏幕分辨率、抗锯齿等。</li>
<li><strong>EditorBuildSettings.asset</strong>：包含了项目的构建设置，如场景列表、目标平台、构建配置等。</li>
</ul>
</li>
<li><strong>Packages 文件夹</strong>：<ul>
<li><strong>manifest.json</strong>：描述了项目使用的 Unity Package Manager（UPM）包和依赖关系。</li>
</ul>
</li>
<li><strong>Temp 文件夹</strong>：<ul>
<li>Unity 编辑器运行时生成的临时文件夹，通常包含临时性质的数据和文件。</li>
</ul>
</li>
<li><strong>Builds 文件夹</strong>：<ul>
<li>可选的，用于存放项目构建生成的输出文件，如游戏可执行文件或打包后的资源文件。</li>
</ul>
</li>
<li><strong>Logs 文件夹</strong>：<ul>
<li>存放 Unity 编辑器和运行时的日志文件，有助于调试和问题排查。</li>
</ul>
</li>
</ol>
<p>自定义结构</p>
<p>除了上述标准结构外，根据项目的特定需求和团队的组织方式，还可以根据以下因素进行自定义组织：</p>
<ul>
<li><strong>场景文件夹</strong>：将不同的场景文件（.unity 文件）按功能或区域进行分组。</li>
<li><strong>脚本文件夹</strong>：将不同类型的脚本文件（C#、JavaScript 等）按功能或模块进行分组。</li>
<li><strong>资源文件夹</strong>：根据不同类型的资源（模型、纹理、音频等）进行分组管理。</li>
<li><strong>插件文件夹</strong>：存放第三方插件或扩展工具的文件夹。</li>
<li><strong>文档和资料文件夹</strong>：存放项目相关的文档、设计文稿和参考资料等。</li>
</ul>
<h2 id="资产文件夹。"><a href="#资产文件夹。" class="headerlink" title="资产文件夹。"></a>资产文件夹。</h2><p>在 Unity 中，资产（Assets）文件夹是项目中存放所有资源文件的核心目录。这些资源包括游戏中使用的模型、纹理、音频、视频、脚本等，可以通过 Unity 编辑器导入、管理和使用。以下是资产文件夹的一些重要特点和常见的资源类型：</p>
<p>特点和用途</p>
<ol>
<li><strong>资源管理</strong>：<ul>
<li>资产文件夹是 Unity 项目的主要资源管理中心，所有用于构建游戏场景、角色、特效等的素材都存放在这里。</li>
</ul>
</li>
<li><strong>导入和导出</strong>：<ul>
<li>可以通过拖放、导入菜单或直接复制文件到资产文件夹中导入资源。Unity 会自动识别支持的文件类型，并在需要时进行格式转换和优化。</li>
</ul>
</li>
<li><strong>组织和结构</strong>：<ul>
<li>可以根据项目的需要在资产文件夹内创建子文件夹，以便更好地组织和管理不同类型的资源。</li>
</ul>
</li>
<li><strong>版本控制</strong>：<ul>
<li>资产文件夹中的内容可以方便地与版本控制系统（如 Git、SVN 等）集成，以便团队成员协作和管理项目文件。</li>
</ul>
</li>
<li><strong>预制件和脚本关联</strong>：<ul>
<li>预制件（Prefab）和脚本文件通常也存放在资产文件夹中。预制件是一种包含游戏对象及其组件配置的资源，可以在场景中多次使用。</li>
</ul>
</li>
</ol>
<p>常见资源类型</p>
<p>在资产文件夹中，可以存放多种类型的资源，包括但不限于：</p>
<ul>
<li><strong>模型（Model）</strong>：3D 或 2D 的网格模型，如角色、道具、环境等。</li>
<li><strong>纹理（Texture）</strong>：用于覆盖模型表面的图像，如皮肤、地表贴图等。</li>
<li><strong>音频（Audio）</strong>：背景音乐、音效等。</li>
<li><strong>动画（Animation）</strong>：角色动作、物体运动的动画文件。</li>
<li><strong>材质（Material）</strong>：定义物体外观的材质属性。</li>
<li><strong>场景（Scene）</strong>：包含游戏对象及其配置的场景文件，如关卡、菜单等。</li>
<li><strong>脚本（Script）</strong>：编写游戏逻辑和行为的脚本文件，通常是 C# 或 Unity 提供的其他脚本语言。</li>
</ul>
<p>资产文件夹的示例结构</p>
<p>一个简单的资产文件夹结构可能如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mathematica</span><br><span class="line">复制代码</span><br><span class="line">Assets/</span><br><span class="line">├── Models/</span><br><span class="line">│   ├── Characters/</span><br><span class="line">│   │   ├── Player.prefab</span><br><span class="line">│   │   ├── Enemy.prefab</span><br><span class="line">│   ├── Environment/</span><br><span class="line">│   │   ├── Trees/</span><br><span class="line">│   │   │   ├── PineTree01.prefab</span><br><span class="line">│   │   │   ├── OakTree01.prefab</span><br><span class="line">├── Textures/</span><br><span class="line">│   ├── CharacterTextures/</span><br><span class="line">│   │   ├── PlayerTexture.png</span><br><span class="line">│   │   ├── EnemyTexture.png</span><br><span class="line">├── Audio/</span><br><span class="line">│   ├── Music/</span><br><span class="line">│   │   ├── BackgroundMusic.mp3</span><br><span class="line">│   ├── SoundEffects/</span><br><span class="line">│   │   ├── JumpSound.wav</span><br><span class="line">├── Scripts/</span><br><span class="line">│   ├── PlayerController.cs</span><br><span class="line">│   ├── EnemyAI.cs</span><br><span class="line">├── Scenes/</span><br><span class="line">│   ├── MainMenu.unity</span><br><span class="line">│   ├── Level1.unity</span><br><span class="line">├── Materials/</span><br><span class="line">│   ├── PlayerMaterial.mat</span><br><span class="line">│   ├── GroundMaterial.mat</span><br></pre></td></tr></table></figure>

<h2 id="如何在visual-studio工程中构建Unity工程文件"><a href="#如何在visual-studio工程中构建Unity工程文件" class="headerlink" title="如何在visual studio工程中构建Unity工程文件"></a>如何在visual studio工程中构建Unity工程文件</h2><p>在 Visual Studio 中构建 Unity 工程文件（Unity project）并不是一个常见的操作，因为 Unity 的项目主要是通过 Unity 编辑器进行构建和管理的。Unity 提供了内置的构建工具来生成游戏的可执行文件或发布包。</p>
<p>然而，有时候可能会希望在 Visual Studio 中进行一些 C# 脚本的编辑、调试或版本控制操作。以下是一些常见的关于在 Visual Studio 中与 Unity 项目一起工作的方法：</p>
<ol>
<li>打开 Unity 项目</li>
</ol>
<p>确保已经在 Unity 编辑器中打开了你的 Unity 项目。</p>
<ol start="2">
<li>生成 Visual Studio 解决方案</li>
</ol>
<p>Unity 会自动在项目文件夹中生成 Visual Studio 解决方案文件（.sln）。如果解决方案文件不存在或需要更新，可以通过以下步骤生成：</p>
<ul>
<li>打开 Unity 编辑器中的项目。</li>
<li>在菜单栏中选择 <strong>Assets</strong> -&gt; <strong>Open C# Project</strong>。这会在项目文件夹中生成或更新 Visual Studio 解决方案文件。</li>
</ul>
<ol start="3">
<li>在 Visual Studio 中打开解决方案</li>
</ol>
<ul>
<li>找到 Unity 项目文件夹中生成的解决方案文件（通常是 .sln 后缀），双击打开它。</li>
<li>Visual Studio 将会加载 Unity 项目的所有 C# 脚本和相关资源。</li>
</ul>
<ol start="4">
<li>编辑和调试 C# 脚本</li>
</ol>
<p>在 Visual Studio 中，你可以编辑 Unity 项目中的 C# 脚本。这些脚本可以通过 Unity 编辑器中的 <strong>Assets</strong> 文件夹进行访问和管理。</p>
<ol start="5">
<li>构建和发布</li>
</ol>
<p>Unity 的构建和发布仍然需要通过 Unity 编辑器完成：</p>
<ul>
<li>在 Unity 编辑器中，选择 <strong>File</strong> -&gt; <strong>Build Settings</strong>。</li>
<li>在 Build Settings 窗口中，选择目标平台和构建选项，并点击 <strong>Build</strong> 或 <strong>Build and Run</strong>。</li>
</ul>
<p>注意事项</p>
<ul>
<li><strong>不要手动编辑生成的项目文件</strong>：Unity 会自动生成和管理 Visual Studio 解决方案文件以及其他支持文件。手动编辑这些文件可能会导致问题或不一致性。</li>
<li><strong>推荐使用 Unity 编辑器的集成开发环境</strong>：Unity 编辑器提供了许多功能和工具，专为开发 Unity 游戏和应用程序而设计。</li>
</ul>

    </div>
    
    
    
    
    
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2022 - 2024 Unique
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Unique
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>
    
    




    
</body>
</html>
